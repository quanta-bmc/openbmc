From 6edd7e9cc21315ab48996438c5e0f447fb36eed0 Mon Sep 17 00:00:00 2001
From: FranHsu <Fran.Hsu@quantatw.com>
Date: Thu, 25 Apr 2019 13:51:43 +0800
Subject: [PATCH] i2c: npcm: version KF debug version.

Add patch for i2c KF debug version.

Signed-off-by: FranHsu <Fran.Hsu@quantatw.com>
---
 drivers/i2c/busses/i2c-npcm7xx.c | 1438 +++++++++++++++---------------
 1 file changed, 732 insertions(+), 706 deletions(-)

diff --git a/drivers/i2c/busses/i2c-npcm7xx.c b/drivers/i2c/busses/i2c-npcm7xx.c
index 53aba723b061..ae84cb0868b1 100644
--- a/drivers/i2c/busses/i2c-npcm7xx.c
+++ b/drivers/i2c/busses/i2c-npcm7xx.c
@@ -20,14 +20,11 @@
 #include <linux/regmap.h>
 #include <linux/jiffies.h>
 
-#define I2C_VERSION "0.0.16"
+#define I2C_VERSION "0.0.21"
 
 //#define _I2C_DEBUG_
 
-enum smb_mode {
-	SMB_SLAVE = 1,
-	SMB_MASTER
-};
+enum smb_mode { SMB_SLAVE = 1, SMB_MASTER };
 
 /*
  * External SMB Interface driver xfer indication values, which indicate status
@@ -51,17 +48,10 @@ enum smb_state_ind {
 };
 
 // SMBus Operation type values
-enum smb_oper {
-	SMB_NO_OPER = 0,
-	SMB_WRITE_OPER = 1,
-	SMB_READ_OPER = 2
-};
+enum smb_oper { SMB_NO_OPER = 0, SMB_WRITE_OPER = 1, SMB_READ_OPER = 2 };
 
 // SMBus Bank (FIFO mode)
-enum smb_bank {
-	SMB_BANK_0 = 0,
-	SMB_BANK_1 = 1
-};
+enum smb_bank { SMB_BANK_0 = 0, SMB_BANK_1 = 1 };
 
 // Internal SMB states values (for the SMB module state machine).
 enum smb_state {
@@ -93,191 +83,190 @@ enum smb_addr {
 static struct regmap *gcr_regmap;
 static struct regmap *clk_regmap;
 
-#define NPCM_I2CSEGCTL  0xE4
-#define NPCM_SECCNT	0x68
-#define NPCM_CNTR25M	0x6C
-#define I2CSEGCTL_VAL	0x0333F000
+#define NPCM_I2CSEGCTL 0xE4
+#define NPCM_SECCNT 0x68
+#define NPCM_CNTR25M 0x6C
+#define I2CSEGCTL_VAL 0x0333F000
 
 // Common regs
-#define NPCM_SMBSDA			0x000
-#define NPCM_SMBST			0x002
-#define NPCM_SMBCST			0x004
-#define NPCM_SMBCTL1			0x006
-#define NPCM_SMBADDR1			0x008
-#define NPCM_SMBCTL2			0x00A
-#define NPCM_SMBADDR2			0x00C
-#define NPCM_SMBCTL3			0x00E
-#define NPCM_SMBCST2			0x018
-#define NPCM_SMBCST3			0x019
-#define SMB_VER				0x01F
+#define NPCM_SMBSDA 0x000
+#define NPCM_SMBST 0x002
+#define NPCM_SMBCST 0x004
+#define NPCM_SMBCTL1 0x006
+#define NPCM_SMBADDR1 0x008
+#define NPCM_SMBCTL2 0x00A
+#define NPCM_SMBADDR2 0x00C
+#define NPCM_SMBCTL3 0x00E
+#define NPCM_SMBCST2 0x018
+#define NPCM_SMBCST3 0x019
+#define SMB_VER 0x01F
 
 // BANK 0 regs
-#define NPCM_SMBADDR3			0x010
-#define NPCM_SMBADDR7			0x011
-#define NPCM_SMBADDR4			0x012
-#define NPCM_SMBADDR8			0x013
-#define NPCM_SMBADDR5			0x014
-#define NPCM_SMBADDR9			0x015
-#define NPCM_SMBADDR6			0x016
-#define NPCM_SMBADDR10			0x017
+#define NPCM_SMBADDR3 0x010
+#define NPCM_SMBADDR7 0x011
+#define NPCM_SMBADDR4 0x012
+#define NPCM_SMBADDR8 0x013
+#define NPCM_SMBADDR5 0x014
+#define NPCM_SMBADDR9 0x015
+#define NPCM_SMBADDR6 0x016
+#define NPCM_SMBADDR10 0x017
 
 // SMBADDR array: because the addr regs are sprincled all over the address space
-const int  NPCM_SMBADDR[10] = {NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
+const int NPCM_SMBADDR[10] = { NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 			       NPCM_SMBADDR4, NPCM_SMBADDR5, NPCM_SMBADDR6,
 			       NPCM_SMBADDR7, NPCM_SMBADDR8, NPCM_SMBADDR9,
-			       NPCM_SMBADDR10};
+			       NPCM_SMBADDR10 };
 
-#define NPCM_SMBCTL4			0x01A
-#define NPCM_SMBCTL5			0x01B
-#define NPCM_SMBSCLLT			0x01C // SCL Low Time
-#define NPCM_SMBFIF_CTL			0x01D // FIFO Control
-#define NPCM_SMBSCLHT			0x01E // SCL High Time
+#define NPCM_SMBCTL4 0x01A
+#define NPCM_SMBCTL5 0x01B
+#define NPCM_SMBSCLLT 0x01C // SCL Low Time
+#define NPCM_SMBFIF_CTL 0x01D // FIFO Control
+#define NPCM_SMBSCLHT 0x01E // SCL High Time
 
 // BANK 1 regs
-#define NPCM_SMBFIF_CTS			0x010 // Both FIFOs Control and status
-#define NPCM_SMBTXF_CTL			0x012 // Tx-FIFO Control
-#define NPCM_SMBT_OUT			0x014 // Bus T.O.
-#define NPCM_SMBPEC			0x016 // PEC Data
-#define NPCM_SMBTXF_STS			0x01A // Tx-FIFO Status
-#define NPCM_SMBRXF_STS			0x01C // Rx-FIFO Status
-#define NPCM_SMBRXF_CTL			0x01E // Rx-FIFO Control
+#define NPCM_SMBFIF_CTS 0x010 // Both FIFOs Control and status
+#define NPCM_SMBTXF_CTL 0x012 // Tx-FIFO Control
+#define NPCM_SMBT_OUT 0x014 // Bus T.O.
+#define NPCM_SMBPEC 0x016 // PEC Data
+#define NPCM_SMBTXF_STS 0x01A // Tx-FIFO Status
+#define NPCM_SMBRXF_STS 0x01C // Rx-FIFO Status
+#define NPCM_SMBRXF_CTL 0x01E // Rx-FIFO Control
 
 // NPCM_SMBST reg fields
-#define NPCM_SMBST_XMIT			BIT(0)
-#define NPCM_SMBST_MASTER		BIT(1)
-#define NPCM_SMBST_NMATCH		BIT(2)
-#define NPCM_SMBST_STASTR		BIT(3)
-#define NPCM_SMBST_NEGACK		BIT(4)
-#define NPCM_SMBST_BER			BIT(5)
-#define NPCM_SMBST_SDAST		BIT(6)
-#define NPCM_SMBST_SLVSTP		BIT(7)
+#define NPCM_SMBST_XMIT BIT(0)
+#define NPCM_SMBST_MASTER BIT(1)
+#define NPCM_SMBST_NMATCH BIT(2)
+#define NPCM_SMBST_STASTR BIT(3)
+#define NPCM_SMBST_NEGACK BIT(4)
+#define NPCM_SMBST_BER BIT(5)
+#define NPCM_SMBST_SDAST BIT(6)
+#define NPCM_SMBST_SLVSTP BIT(7)
 
 // NPCM_SMBCST reg fields
-#define NPCM_SMBCST_BUSY		BIT(0)
-#define NPCM_SMBCST_BB			BIT(1)
-#define NPCM_SMBCST_MATCH		BIT(2)
-#define NPCM_SMBCST_GCMATCH		BIT(3)
-#define NPCM_SMBCST_TSDA		BIT(4)
-#define NPCM_SMBCST_TGSCL		BIT(5)
-#define NPCM_SMBCST_MATCHAF		BIT(6)
-#define NPCM_SMBCST_ARPMATCH		BIT(7)
+#define NPCM_SMBCST_BUSY BIT(0)
+#define NPCM_SMBCST_BB BIT(1)
+#define NPCM_SMBCST_MATCH BIT(2)
+#define NPCM_SMBCST_GCMATCH BIT(3)
+#define NPCM_SMBCST_TSDA BIT(4)
+#define NPCM_SMBCST_TGSCL BIT(5)
+#define NPCM_SMBCST_MATCHAF BIT(6)
+#define NPCM_SMBCST_ARPMATCH BIT(7)
 
 // NPCM_SMBCTL1 reg fields
-#define NPCM_SMBCTL1_START		BIT(0)
-#define NPCM_SMBCTL1_STOP		BIT(1)
-#define NPCM_SMBCTL1_INTEN		BIT(2)
-#define NPCM_SMBCTL1_EOBINTE		BIT(3)
-#define NPCM_SMBCTL1_ACK		BIT(4)
-#define NPCM_SMBCTL1_GCMEN		BIT(5)
-#define NPCM_SMBCTL1_NMINTE		BIT(6)
-#define NPCM_SMBCTL1_STASTRE		BIT(7)
+#define NPCM_SMBCTL1_START BIT(0)
+#define NPCM_SMBCTL1_STOP BIT(1)
+#define NPCM_SMBCTL1_INTEN BIT(2)
+#define NPCM_SMBCTL1_EOBINTE BIT(3)
+#define NPCM_SMBCTL1_ACK BIT(4)
+#define NPCM_SMBCTL1_GCMEN BIT(5)
+#define NPCM_SMBCTL1_NMINTE BIT(6)
+#define NPCM_SMBCTL1_STASTRE BIT(7)
 
 // RW1S fields (inside a RW reg):
-#define NPCM_SMBCTL1_RWS_FIELDS	  (NPCM_SMBCTL1_START | NPCM_SMBCTL1_STOP | \
-				   NPCM_SMBCTL1_ACK)
+#define NPCM_SMBCTL1_RWS_FIELDS                                                \
+	(NPCM_SMBCTL1_START | NPCM_SMBCTL1_STOP | NPCM_SMBCTL1_ACK)
 // NPCM_SMBADDR reg fields
-#define NPCM_SMBADDR_ADDR		GENMASK(6, 0)
-#define NPCM_SMBADDR_SAEN		BIT(7)
+#define NPCM_SMBADDR_ADDR GENMASK(6, 0)
+#define NPCM_SMBADDR_SAEN BIT(7)
 
 // NPCM_SMBCTL2 reg fields
-#define SMBCTL2_ENABLE			BIT(0)
-#define SMBCTL2_SCLFRQ6_0		GENMASK(7, 1)
+#define SMBCTL2_ENABLE BIT(0)
+#define SMBCTL2_SCLFRQ6_0 GENMASK(7, 1)
 
 // NPCM_SMBCTL3 reg fields
-#define SMBCTL3_SCLFRQ8_7		GENMASK(1, 0)
-#define SMBCTL3_ARPMEN			BIT(2)
-#define SMBCTL3_IDL_START		BIT(3)
-#define SMBCTL3_400K_MODE		BIT(4)
-#define SMBCTL3_BNK_SEL			BIT(5)
-#define SMBCTL3_SDA_LVL			BIT(6)
-#define SMBCTL3_SCL_LVL			BIT(7)
+#define SMBCTL3_SCLFRQ8_7 GENMASK(1, 0)
+#define SMBCTL3_ARPMEN BIT(2)
+#define SMBCTL3_IDL_START BIT(3)
+#define SMBCTL3_400K_MODE BIT(4)
+#define SMBCTL3_BNK_SEL BIT(5)
+#define SMBCTL3_SDA_LVL BIT(6)
+#define SMBCTL3_SCL_LVL BIT(7)
 
 // NPCM_SMBCST2 reg fields
-#define NPCM_SMBCST2_MATCHA1F		BIT(0)
-#define NPCM_SMBCST2_MATCHA2F		BIT(1)
-#define NPCM_SMBCST2_MATCHA3F		BIT(2)
-#define NPCM_SMBCST2_MATCHA4F		BIT(3)
-#define NPCM_SMBCST2_MATCHA5F		BIT(4)
-#define NPCM_SMBCST2_MATCHA6F		BIT(5)
-#define NPCM_SMBCST2_MATCHA7F		BIT(5)
-#define NPCM_SMBCST2_INTSTS		BIT(7)
+#define NPCM_SMBCST2_MATCHA1F BIT(0)
+#define NPCM_SMBCST2_MATCHA2F BIT(1)
+#define NPCM_SMBCST2_MATCHA3F BIT(2)
+#define NPCM_SMBCST2_MATCHA4F BIT(3)
+#define NPCM_SMBCST2_MATCHA5F BIT(4)
+#define NPCM_SMBCST2_MATCHA6F BIT(5)
+#define NPCM_SMBCST2_MATCHA7F BIT(5)
+#define NPCM_SMBCST2_INTSTS BIT(7)
 
 // NPCM_SMBCST3 reg fields
-#define NPCM_SMBCST3_MATCHA8F		BIT(0)
-#define NPCM_SMBCST3_MATCHA9F		BIT(1)
-#define NPCM_SMBCST3_MATCHA10F		BIT(2)
-#define NPCM_SMBCST3_EO_BUSY		BIT(7)
+#define NPCM_SMBCST3_MATCHA8F BIT(0)
+#define NPCM_SMBCST3_MATCHA9F BIT(1)
+#define NPCM_SMBCST3_MATCHA10F BIT(2)
+#define NPCM_SMBCST3_EO_BUSY BIT(7)
 
 // NPCM_SMBCTL4 reg fields
-#define SMBCTL4_HLDT			GENMASK(5, 0)
-#define SMBCTL4_LVL_WE			BIT(7)
+#define SMBCTL4_HLDT GENMASK(5, 0)
+#define SMBCTL4_LVL_WE BIT(7)
 
 // NPCM_SMBCTL5 reg fields
-#define SMBCTL5_DBNCT			GENMASK(3, 0)
+#define SMBCTL5_DBNCT GENMASK(3, 0)
 
 // NPCM_SMBFIF_CTS reg fields
-#define NPCM_SMBFIF_CTS_RXF_TXE		BIT(1)
-#define NPCM_SMBFIF_CTS_RFTE_IE		BIT(3)
-#define NPCM_SMBFIF_CTS_CLR_FIFO	BIT(6)
-#define NPCM_SMBFIF_CTS_SLVRSTR		BIT(7)
+#define NPCM_SMBFIF_CTS_RXF_TXE BIT(1)
+#define NPCM_SMBFIF_CTS_RFTE_IE BIT(3)
+#define NPCM_SMBFIF_CTS_CLR_FIFO BIT(6)
+#define NPCM_SMBFIF_CTS_SLVRSTR BIT(7)
 
 // NPCM_SMBTXF_CTL reg fields
 #ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBTXF_CTL_TX_THR		GENMASK(5, 0)
+#define NPCM_SMBTXF_CTL_TX_THR GENMASK(5, 0)
 #else
-#define NPCM_SMBTXF_CTL_TX_THR		GENMASK(4, 0)
+#define NPCM_SMBTXF_CTL_TX_THR GENMASK(4, 0)
 #endif
-#define NPCM_SMBTXF_CTL_THR_TXIE	BIT(6)
+#define NPCM_SMBTXF_CTL_THR_TXIE BIT(6)
 
 // NPCM_SMBT_OUT reg fields
-#define NPCM_SMBT_OUT_TO_CKDIV		GENMASK(5, 0)
-#define NPCM_SMBT_OUT_T_OUTIE		BIT(6)
-#define NPCM_SMBT_OUT_T_OUTST		BIT(7)
+#define NPCM_SMBT_OUT_TO_CKDIV GENMASK(5, 0)
+#define NPCM_SMBT_OUT_T_OUTIE BIT(6)
+#define NPCM_SMBT_OUT_T_OUTST BIT(7)
 
 // NPCM_SMBTXF_STS reg fields
 #ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBTXF_STS_TX_BYTES	GENMASK(5, 0)
+#define NPCM_SMBTXF_STS_TX_BYTES GENMASK(5, 0)
 #else
-#define NPCM_SMBTXF_STS_TX_BYTES	GENMASK(4, 0)
+#define NPCM_SMBTXF_STS_TX_BYTES GENMASK(4, 0)
 #endif
-#define NPCM_SMBTXF_STS_TX_THST		BIT(6)
+#define NPCM_SMBTXF_STS_TX_THST BIT(6)
 
 // NPCM_SMBRXF_STS reg fields
 #ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBRXF_STS_RX_BYTES	GENMASK(5, 0)
+#define NPCM_SMBRXF_STS_RX_BYTES GENMASK(5, 0)
 #else
-#define NPCM_SMBRXF_STS_RX_BYTES	GENMASK(4, 0)
+#define NPCM_SMBRXF_STS_RX_BYTES GENMASK(4, 0)
 #endif
-#define NPCM_SMBRXF_STS_RX_THST		BIT(6)
+#define NPCM_SMBRXF_STS_RX_THST BIT(6)
 
 // NPCM_SMBFIF_CTL reg fields
-#define NPCM_SMBFIF_CTL_FIFO_EN		BIT(4)
+#define NPCM_SMBFIF_CTL_FIFO_EN BIT(4)
 
 // NPCM_SMBRXF_CTL reg fields
 // Note: on the next HW version of this module, this HW is about to switch to
 //	 32 bytes FIFO. This size will be set using a config.
 //	 on current version 16 bytes FIFO is set using a define
 #ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBRXF_CTL_RX_THR		GENMASK(5, 0)
-#define NPCM_SMBRXF_CTL_LAST_PEC	BIT(7)
-#define SMBUS_FIFO_SIZE			32
+#define NPCM_SMBRXF_CTL_RX_THR GENMASK(5, 0)
+#define NPCM_SMBRXF_CTL_LAST_PEC BIT(7)
+#define SMBUS_FIFO_SIZE 32
 #else
-#define NPCM_SMBRXF_CTL_RX_THR		GENMASK(4, 0)
-#define NPCM_SMBRXF_CTL_LAST_PEC	BIT(5)
-#define SMBUS_FIFO_SIZE			16
+#define NPCM_SMBRXF_CTL_RX_THR GENMASK(4, 0)
+#define NPCM_SMBRXF_CTL_LAST_PEC BIT(5)
+#define SMBUS_FIFO_SIZE 16
 #endif
-#define NPCM_SMBRXF_CTL_THR_RXIE	BIT(6)
-
+#define NPCM_SMBRXF_CTL_THR_RXIE BIT(6)
 
 // SMB_VER reg fields
-#define SMB_VER_VERSION			GENMASK(6, 0)
-#define SMB_VER_FIFO_EN			BIT(7)
+#define SMB_VER_VERSION GENMASK(6, 0)
+#define SMB_VER_FIFO_EN BIT(7)
 
 // stall/stuck timeout
-const unsigned int DEFAULT_STALL_COUNT =	25;
+const unsigned int DEFAULT_STALL_COUNT = 25;
 
 // Data abort timeout
-const unsigned int ABORT_TIMEOUT =	 10000;
+const unsigned int ABORT_TIMEOUT = 10000;
 
 // SMBus spec. values in KHZ
 const unsigned int SMBUS_FREQ_MIN = 10;
@@ -291,36 +280,35 @@ const unsigned int SCLFRQ_MIN = 10;
 const unsigned int SCLFRQ_MAX = 511;
 
 // SCLFRQ field position
-#define SCLFRQ_0_TO_6		GENMASK(6, 0)
-#define SCLFRQ_7_TO_8		GENMASK(8, 7)
+#define SCLFRQ_0_TO_6 GENMASK(6, 0)
+#define SCLFRQ_7_TO_8 GENMASK(8, 7)
 
 // SMB Maximum Retry Trials (on Bus Arbitration Loss)
 const unsigned int SMB_RETRY_MAX_COUNT = 2;
 const unsigned int SMB_NUM_OF_ADDR = 10;
 
 // for logging:
-#define NPCM_I2C_EVENT_START	BIT(0)
-#define NPCM_I2C_EVENT_STOP	BIT(1)
-#define NPCM_I2C_EVENT_ABORT	BIT(2)
-#define NPCM_I2C_EVENT_WRITE	BIT(3)
-
-#define NPCM_I2C_EVENT_READ	BIT(4)
-#define NPCM_I2C_EVENT_BER	BIT(5)
-#define NPCM_I2C_EVENT_NACK	BIT(6)
-#define NPCM_I2C_EVENT_TO	BIT(7)
+#define NPCM_I2C_EVENT_START BIT(0)
+#define NPCM_I2C_EVENT_STOP BIT(1)
+#define NPCM_I2C_EVENT_ABORT BIT(2)
+#define NPCM_I2C_EVENT_WRITE BIT(3)
 
-#define NPCM_I2C_EVENT_EOB	BIT(8)
-#define NPCM_I2C_EVENT_STALL	BIT(9)
-#define NPCM_I2C_EVENT_CB	BIT(10)
-#define NPCM_I2C_EVENT_DONE	BIT(11)
+#define NPCM_I2C_EVENT_READ BIT(4)
+#define NPCM_I2C_EVENT_BER BIT(5)
+#define NPCM_I2C_EVENT_NACK BIT(6)
+#define NPCM_I2C_EVENT_TO BIT(7)
 
-#define NPCM_I2C_EVENT_READ1	BIT(12)
-#define NPCM_I2C_EVENT_READ2	BIT(13)
-#define NPCM_I2C_EVENT_READ3	BIT(14)
-#define NPCM_I2C_EVENT_READ4	BIT(15)
+#define NPCM_I2C_EVENT_EOB BIT(8)
+#define NPCM_I2C_EVENT_STALL BIT(9)
+#define NPCM_I2C_EVENT_CB BIT(10)
+#define NPCM_I2C_EVENT_DONE BIT(11)
 
+#define NPCM_I2C_EVENT_READ1 BIT(12)
+#define NPCM_I2C_EVENT_READ2 BIT(13)
+#define NPCM_I2C_EVENT_READ3 BIT(14)
+#define NPCM_I2C_EVENT_READ4 BIT(15)
 
-#define NPCM_I2C_EVENT_LOG(event)   (bus->event_log |= event)
+#define NPCM_I2C_EVENT_LOG(event) (bus->event_log |= event)
 
 #define SMB_RECOVERY_SUPPORT
 
@@ -330,48 +318,48 @@ const unsigned int SMB_NUM_OF_ADDR = 10;
 
 // Status of one SMBus module
 struct npcm_i2c {
-	struct i2c_adapter	adap;
-	struct device		*dev;
-	unsigned char __iomem	*reg;
-	spinlock_t		lock;   /* IRQ synchronization */
-	struct completion	cmd_complete;
-	int			irq;
-	int			cmd_err;
-	struct i2c_msg		*msgs;
-	int			msgs_num;
-	int			num;
-	u32			apb_clk;
-	enum smb_state		state;
-	enum smb_oper		operation;
-	enum smb_mode		master_or_slave;
-	enum smb_state_ind	stop_ind;
-	u8			dest_addr;
-	u8			*rd_buf;
-	u16			rd_size;
-	u16			rd_ind;
-	u8			*wr_buf;
-	u16			wr_size;
-	u16			wr_ind;
-	bool			fifo_use;
-	u16			threshold_fifo;
+	struct i2c_adapter adap;
+	struct device *dev;
+	unsigned char __iomem *reg;
+	spinlock_t lock; /* IRQ synchronization */
+	struct completion cmd_complete;
+	int irq;
+	int cmd_err;
+	struct i2c_msg *msgs;
+	int msgs_num;
+	int num;
+	u32 apb_clk;
+	enum smb_state state;
+	enum smb_oper operation;
+	enum smb_mode master_or_slave;
+	enum smb_state_ind stop_ind;
+	u8 dest_addr;
+	u8 *rd_buf;
+	u16 rd_size;
+	u16 rd_ind;
+	u8 *wr_buf;
+	u16 wr_size;
+	u16 wr_ind;
+	bool fifo_use;
+	u16 threshold_fifo;
 
 	// PEC bit mask per slave address.
 	//		1: use PEC for this address,
 	//		0: do not use PEC for this address
-	u16			PEC_mask;
-	bool			PEC_use;
-	u8			crc_data;
-	bool			read_block_use;
-	u8			retry_count;
-	u8			int_cnt;
-	u32			event_log;
-	u32			event_log_prev;
-	u32			clk_period_us;
-	unsigned long 			int_time_stamp;
+	u16 PEC_mask;
+	bool PEC_use;
+	u8 crc_data;
+	bool read_block_use;
+	u8 retry_count;
+	u8 int_cnt;
+	u32 event_log;
+	u32 event_log_prev;
+	u32 clk_period_us;
+	unsigned long int_time_stamp;
 
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
-	u8				own_slave_addr;
-	struct i2c_client		*slave;
+	u8 own_slave_addr;
+	struct i2c_client *slave;
 
 	// currently I2C slave IF only supports single byte operations.
 	// in order to utilyze the npcm HW FIFO, the driver will ask for 16bytes
@@ -382,19 +370,16 @@ struct npcm_i2c {
 
 	// This module can be master and slave at the same time. seperate ptrs
 	// and counters:
-	int			slv_rd_size;
-	int			slv_rd_ind;
-	int			slv_wr_size;
-	int			slv_wr_ind;
+	int slv_rd_size;
+	int slv_rd_ind;
+	int slv_wr_size;
+	int slv_wr_ind;
 
-	u8 			slv_rd_buf[SMBUS_FIFO_SIZE];
-	u8 			slv_wr_buf[SMBUS_FIFO_SIZE];
+	u8 slv_rd_buf[SMBUS_FIFO_SIZE];
+	u8 slv_wr_buf[SMBUS_FIFO_SIZE];
 #endif
-
 };
 
-
-
 static inline void npcm_smb_select_bank(struct npcm_i2c *bus,
 					enum smb_bank bank)
 {
@@ -410,6 +395,9 @@ static inline void npcm_smb_select_bank(struct npcm_i2c *bus,
 // DEBUG PRINTS:
 //------------------
 static inline bool npcm_smb_is_quick(struct npcm_i2c *bus);
+
+static struct npcm_i2c *buss[16];
+
 static void pdebug(struct npcm_i2c *bus, char str[20])
 {
 	char str2[65];
@@ -502,22 +490,22 @@ static void pdebug(struct npcm_i2c *bus, char str[20])
 		break;
 	}
 	switch (bus->state) {
-	case  SMB_DISABLE:
+	case SMB_DISABLE:
 		s += sprintf(s, "DISABLE      ");
 		break;
-	case  SMB_IDLE:
+	case SMB_IDLE:
 		s += sprintf(s, "IDLE	      ");
 		break;
-	case  SMB_MASTER_START:
+	case SMB_MASTER_START:
 		s += sprintf(s, "MASTER_START ");
 		break;
-	case  SMB_SLAVE_MATCH:
+	case SMB_SLAVE_MATCH:
 		s += sprintf(s, "SLAVE_MATCH  ");
 		break;
-	case  SMB_OPER_STARTED:
+	case SMB_OPER_STARTED:
 		s += sprintf(s, "OPER_STARTED ");
 		break;
-	case  SMB_STOP_PENDING:
+	case SMB_STOP_PENDING:
 		s += sprintf(s, "STOP_PENDING ");
 		break;
 	}
@@ -525,20 +513,19 @@ static void pdebug(struct npcm_i2c *bus, char str[20])
 	//npcm_smb_select_bank(bus, SMB_BANK_1);
 
 	printk("%s %s wr%d,%d rd%d,%d int%d ev0x%02x (prv=0x%02x) blk%d ST=%02x CST=%02x CTL1=%02x CTL3=%02x FIF_CTS=%02x TXF_CTL=%02x T_OUT=%02x CST2=%02x CST3=%02x TXF_STS=%02x RXF_STS=%02x RXF_CTL=%02x ",
-		str2, str, wr_size, wr_ind, rd_size, rd_ind,
-		bus->int_cnt, bus->event_log, bus->event_log_prev, (int)bus->read_block_use,
-		ioread8(bus->reg + NPCM_SMBST),
-		ioread8(bus->reg + NPCM_SMBCST),
-		ioread8(bus->reg + NPCM_SMBCTL1 ),
-		ioread8(bus->reg + NPCM_SMBCTL3 ),
-		ioread8(bus->reg + NPCM_SMBFIF_CTS ),
-		ioread8(bus->reg + NPCM_SMBTXF_CTL ),
-		ioread8(bus->reg + NPCM_SMBT_OUT),
-		ioread8(bus->reg + NPCM_SMBCST2 ),
-		ioread8(bus->reg + NPCM_SMBCST3 ),
-		ioread8(bus->reg + NPCM_SMBTXF_STS ),
-		ioread8(bus->reg + NPCM_SMBRXF_STS ),
-		ioread8(bus->reg + NPCM_SMBRXF_CTL )  );
+	       str2, str, wr_size, wr_ind, rd_size, rd_ind, bus->int_cnt,
+	       bus->event_log, bus->event_log_prev, (int)bus->read_block_use,
+	       ioread8(bus->reg + NPCM_SMBST), ioread8(bus->reg + NPCM_SMBCST),
+	       ioread8(bus->reg + NPCM_SMBCTL1),
+	       ioread8(bus->reg + NPCM_SMBCTL3),
+	       ioread8(bus->reg + NPCM_SMBFIF_CTS),
+	       ioread8(bus->reg + NPCM_SMBTXF_CTL),
+	       ioread8(bus->reg + NPCM_SMBT_OUT),
+	       ioread8(bus->reg + NPCM_SMBCST2),
+	       ioread8(bus->reg + NPCM_SMBCST3),
+	       ioread8(bus->reg + NPCM_SMBTXF_STS),
+	       ioread8(bus->reg + NPCM_SMBRXF_STS),
+	       ioread8(bus->reg + NPCM_SMBRXF_CTL));
 
 	//npcm_smb_select_bank(bus, SMB_BANK_0);
 	//printk("CTL4=%02x CTL5=%02x FIF_CTL=%02x\n",
@@ -546,9 +533,23 @@ static void pdebug(struct npcm_i2c *bus, char str[20])
 	//	ioread8(bus->reg + NPCM_SMBCTL5 ),
 	//	ioread8(bus->reg + NPCM_SMBFIF_CTL ));
 	//npcm_smb_select_bank(bus, SMB_BANK_1);
-	return;
 
+	if (str[0] != '#') {
+		if (bus->num == 0)
+			pdebug(buss[1], "#1_");
+		if (bus->num == 1)
+			pdebug(buss[0], "#0_");
+		if (bus->num == 6)
+			pdebug(buss[7], "#7_");
+		if (bus->num == 7)
+			pdebug(buss[6], "#6_");
+		if (bus->num == 8)
+			pdebug(buss[9], "#9_");
+		if (bus->num == 9)
+			pdebug(buss[8], "#8_");
+	}
 
+	return;
 }
 
 static void pdebug_lvl2(struct npcm_i2c *bus, char str[20])
@@ -560,10 +561,8 @@ static void pdebug_lvl2(struct npcm_i2c *bus, char str[20])
 	pdebug(bus, str);
 }
 
-
 DECLARE_CRC8_TABLE(npcm7xx_crc8);
 
-
 static void npcm_smb_init_params(struct npcm_i2c *bus)
 {
 	bus->stop_ind = SMB_NO_STATUS_IND;
@@ -576,16 +575,16 @@ static void npcm_smb_init_params(struct npcm_i2c *bus)
 	bus->slv_rd_ind = 0;
 	bus->slv_wr_ind = 0;
 	//bus->operation = SMB_NO_OPER;
-	bus->retry_count = 1;  // SMB_RETRY_MAX_COUNT;
+	bus->retry_count = 1; // SMB_RETRY_MAX_COUNT;
 	bus->int_cnt = 0;
 	bus->event_log_prev = bus->event_log;
 	bus->event_log = 0;
 	bus->read_block_use = false;
 	bus->int_time_stamp = 0;
-	bus->cmd_err = -EPERM;
+	bus->cmd_err = -EBUSY;
 	bus->PEC_use = false;
 	bus->PEC_mask = 0;
-	if(bus->slave)
+	if (bus->slave)
 		bus->master_or_slave = SMB_SLAVE;
 	bus->threshold_fifo = SMBUS_FIFO_SIZE;
 
@@ -638,7 +637,7 @@ static int npcm_smb_get_SCL(struct i2c_adapter *_adap)
 	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
 
 	// Get SCL level
-	ret = FIELD_GET(SMBCTL3_SCL_LVL,  ioread8(bus->reg + NPCM_SMBCTL3));
+	ret = FIELD_GET(SMBCTL3_SCL_LVL, ioread8(bus->reg + NPCM_SMBCTL3));
 
 	return ret;
 }
@@ -649,7 +648,7 @@ static int npcm_smb_get_SDA(struct i2c_adapter *_adap)
 	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
 
 	// Get SDA level
-	ret = FIELD_GET(SMBCTL3_SDA_LVL,  ioread8(bus->reg + NPCM_SMBCTL3));
+	ret = FIELD_GET(SMBCTL3_SDA_LVL, ioread8(bus->reg + NPCM_SMBCTL3));
 
 	return ret;
 }
@@ -702,21 +701,38 @@ static void npcm_smb_enable(struct npcm_i2c *bus)
 		 bus->reg + NPCM_SMBCTL2);
 }
 
+static bool npcm_smb_wait_for_bus_free(struct npcm_i2c *bus)
+{
+	unsigned long timeout1 = jiffies + bus->adap.timeout;
+	while ((ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BB) == 1) {
+		if (time_after(jiffies, timeout1)) {
+			pdebug(bus, "ETIMEDOUT");
+			bus->cmd_err = -ETIMEDOUT;
+			return false;
+		}
+		cpu_relax();
+	}
+	return true;
+}
+
 // enable\disable end of busy (EOB) interrupt
 static inline void npcm_smb_eob_int(struct npcm_i2c *bus, bool enable)
 {
 	if (enable) {
 		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) |
-			 NPCM_SMBCTL1_EOBINTE)  & ~NPCM_SMBCTL1_RWS_FIELDS,
+			  NPCM_SMBCTL1_EOBINTE) &
+				 ~NPCM_SMBCTL1_RWS_FIELDS,
 			 bus->reg + NPCM_SMBCTL1);
 	} else {
 		iowrite8(ioread8(bus->reg + NPCM_SMBCTL1) &
-			 ~NPCM_SMBCTL1_EOBINTE & ~NPCM_SMBCTL1_RWS_FIELDS,
+				 ~NPCM_SMBCTL1_EOBINTE &
+				 ~NPCM_SMBCTL1_RWS_FIELDS,
 			 bus->reg + NPCM_SMBCTL1);
 
 		// Clear EO_BUSY pending bit:
 		iowrite8(ioread8(bus->reg + NPCM_SMBCST3) |
-			 NPCM_SMBCST3_EO_BUSY, bus->reg + NPCM_SMBCST3);
+				 NPCM_SMBCST3_EO_BUSY,
+			 bus->reg + NPCM_SMBCST3);
 	}
 }
 
@@ -746,16 +762,14 @@ static inline bool npcm_smb_rx_fifo_full(struct npcm_i2c *bus)
 			       ioread8(bus->reg + NPCM_SMBRXF_STS));
 }
 
-
 static inline void npcm_smb_clear_fifo_int(struct npcm_i2c *bus)
 {
 	iowrite8((ioread8(bus->reg + NPCM_SMBFIF_CTS) &
-			NPCM_SMBFIF_CTS_SLVRSTR) |
-			NPCM_SMBFIF_CTS_RXF_TXE,
-			bus->reg + NPCM_SMBFIF_CTS);
+		  NPCM_SMBFIF_CTS_SLVRSTR) |
+			 NPCM_SMBFIF_CTS_RXF_TXE,
+		 bus->reg + NPCM_SMBFIF_CTS);
 }
 
-
 static inline void npcm_smb_clear_tx_fifo(struct npcm_i2c *bus)
 {
 	iowrite8(ioread8(bus->reg + NPCM_SMBTXF_STS) | NPCM_SMBTXF_STS_TX_THST,
@@ -765,18 +779,20 @@ static inline void npcm_smb_clear_tx_fifo(struct npcm_i2c *bus)
 static inline void npcm_smb_clear_rx_fifo(struct npcm_i2c *bus)
 {
 	iowrite8(ioread8(bus->reg + NPCM_SMBRXF_STS) | NPCM_SMBRXF_STS_RX_THST,
-			 bus->reg + NPCM_SMBRXF_STS);
+		 bus->reg + NPCM_SMBRXF_STS);
 }
 
 static void npcm_smb_int_enable(struct npcm_i2c *bus, bool enable)
 {
 	if (enable)
 		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) |
-			 NPCM_SMBCTL1_INTEN) & ~NPCM_SMBCTL1_RWS_FIELDS,
+			  NPCM_SMBCTL1_INTEN) &
+				 ~NPCM_SMBCTL1_RWS_FIELDS,
 			 bus->reg + NPCM_SMBCTL1);
 	else
 		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) &
-			 ~NPCM_SMBCTL1_INTEN) & ~NPCM_SMBCTL1_RWS_FIELDS,
+			  ~NPCM_SMBCTL1_INTEN) &
+				 ~NPCM_SMBCTL1_RWS_FIELDS,
 			 bus->reg + NPCM_SMBCTL1);
 }
 
@@ -785,13 +801,12 @@ static inline void npcm_smb_master_start(struct npcm_i2c *bus)
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_START);
 
 	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_START) &
-		 ~(NPCM_SMBCTL1_STOP | NPCM_SMBCTL1_ACK),
+			 ~(NPCM_SMBCTL1_STOP | NPCM_SMBCTL1_ACK),
 		 bus->reg + NPCM_SMBCTL1);
 }
 
 static void npcm_smb_set_fifo(struct npcm_i2c *bus, int nread, int nwrite);
 
-
 static inline void npcm_smb_master_stop(struct npcm_i2c *bus)
 {
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_STOP);
@@ -804,7 +819,7 @@ static inline void npcm_smb_master_stop(struct npcm_i2c *bus)
 	udelay(10);
 
 	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_STOP) &
-		 ~(NPCM_SMBCTL1_START | NPCM_SMBCTL1_ACK),
+			 ~(NPCM_SMBCTL1_START | NPCM_SMBCTL1_ACK),
 		 bus->reg + NPCM_SMBCTL1);
 
 	if (bus->fifo_use) {
@@ -821,23 +836,24 @@ static inline void npcm_smb_master_stop(struct npcm_i2c *bus)
 	}
 }
 
-
 static inline void npcm_smb_stall_after_start(struct npcm_i2c *bus, bool stall)
 {
 	if (stall)
 		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) |
-			 NPCM_SMBCTL1_STASTRE)  & ~NPCM_SMBCTL1_RWS_FIELDS,
+			  NPCM_SMBCTL1_STASTRE) &
+				 ~NPCM_SMBCTL1_RWS_FIELDS,
 			 bus->reg + NPCM_SMBCTL1);
 	else
 		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) &
-			 ~NPCM_SMBCTL1_STASTRE)  & ~NPCM_SMBCTL1_RWS_FIELDS,
+			  ~NPCM_SMBCTL1_STASTRE) &
+				 ~NPCM_SMBCTL1_RWS_FIELDS,
 			 bus->reg + NPCM_SMBCTL1);
 }
 
 static inline void npcm_smb_nack(struct npcm_i2c *bus)
 {
 	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_ACK) &
-		 ~(NPCM_SMBCTL1_STOP | NPCM_SMBCTL1_START),
+			 ~(NPCM_SMBCTL1_STOP | NPCM_SMBCTL1_START),
 		 bus->reg + NPCM_SMBCTL1);
 }
 
@@ -881,7 +897,6 @@ static inline bool npcm_smb_is_master(struct npcm_i2c *bus)
 			       ioread8(bus->reg + NPCM_SMBST));
 }
 
-
 static void npcm_smb_callback(struct npcm_i2c *bus,
 			      enum smb_state_ind op_status, u16 info)
 {
@@ -890,46 +905,49 @@ static void npcm_smb_callback(struct npcm_i2c *bus,
 
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_CB);
 
+	if (completion_done(&bus->cmd_complete) == true) {
+		pdebug(bus, "CB com err");
+	}
+
 	switch (op_status) {
 	case SMB_MASTER_DONE_IND:
-	// Master transaction finished and all transmit bytes were sent
-	// info: number of bytes actually received after the Master
-	//	receive operation (if Master didn't issue receive it
-	//	should be 0)
-	// Notify that not all data was received on Master or Slave
-	// info:
-	//	on receive: number of actual bytes received
-	//	when PEC is used even if 'info' is the expected number
-	//	of bytes, it means that PEC error occurred.
-	{
-		if (msgs[0].flags & I2C_M_RD)
-			msgs[0].len = info;
-		else if (msgs_num == 2 && msgs[1].flags & I2C_M_RD)
-			msgs[1].len = info;
-
-		bus->cmd_err = 0;
-		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_DONE);
-
-		if((ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BB) != 0)
-			pdebug_lvl2(bus, "WARNING busy done");
-		complete(&bus->cmd_complete);
-		if(bus->slave)
-		    bus->master_or_slave = SMB_SLAVE;
-	}
-	break;
+		// Master transaction finished and all transmit bytes were sent
+		// info: number of bytes actually received after the Master
+		//	receive operation (if Master didn't issue receive it
+		//	should be 0)
+		// Notify that not all data was received on Master or Slave
+		// info:
+		//	on receive: number of actual bytes received
+		//	when PEC is used even if 'info' is the expected number
+		//	of bytes, it means that PEC error occurred.
+		{
+			if (bus->msgs != NULL) {
+				if (msgs[0].flags & I2C_M_RD)
+					msgs[0].len = info;
+				else if (msgs_num == 2 &&
+					 msgs[1].flags & I2C_M_RD)
+					msgs[1].len = info;
+			}
+			bus->cmd_err = 0;
+			NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_DONE);
+
+			if ((ioread8(bus->reg + NPCM_SMBCST) &
+			     NPCM_SMBCST_BB) != 0)
+				pdebug_lvl2(bus, "WARNING busy done");
+			if (completion_done(&bus->cmd_complete) == false)
+				complete(&bus->cmd_complete);
+		}
+		break;
 
 	case SMB_NACK_IND:
 		// MASTER transmit got a NAK before transmitting all bytes
 		// info: number of transmitted bytes
-		bus->cmd_err = -EAGAIN;
+		bus->cmd_err = -ENXIO;
 		pdebug_lvl2(bus, "CB-NACK ");
 		if (bus->master_or_slave == SMB_MASTER) {
 			complete(&bus->cmd_complete);
-			if(bus->slave)
-			    bus->master_or_slave = SMB_SLAVE;
 		}
 
-
 		break;
 	case SMB_BUS_ERR_IND:
 		// Bus error
@@ -938,9 +956,6 @@ static void npcm_smb_callback(struct npcm_i2c *bus,
 		pdebug_lvl2(bus, "CB BER  ");
 		if (bus->master_or_slave == SMB_MASTER) {
 			complete(&bus->cmd_complete);
-			if(bus->slave)
-			    bus->master_or_slave = SMB_SLAVE;
-
 		}
 
 		break;
@@ -953,10 +968,12 @@ static void npcm_smb_callback(struct npcm_i2c *bus,
 		pdebug_lvl2(bus, "CB default");
 		break;
 	}
+
 	bus->operation = SMB_NO_OPER;
+	if (bus->slave)
+		bus->master_or_slave = SMB_SLAVE;
 }
 
-
 static u32 npcm_smb_get_fifo_fullness(struct npcm_i2c *bus)
 {
 	if (bus->operation == SMB_WRITE_OPER)
@@ -968,15 +985,16 @@ static u32 npcm_smb_get_fifo_fullness(struct npcm_i2c *bus)
 	return 0;
 }
 
-
 static void npcm_smb_write_to_fifo_master(struct npcm_i2c *bus,
 					  u16 max_bytes_to_send)
 {
 	pdebug_lvl2(bus, "wr_fifo_master");
 	// Fill the FIFO, while the FIFO is not full and there are more bytes to
 	// write
-	while ((max_bytes_to_send--) && (SMBUS_FIFO_SIZE -
-					 npcm_smb_get_fifo_fullness(bus))) {
+	if (max_bytes_to_send == 0)
+		return;
+	while ((max_bytes_to_send--) &&
+	       (SMBUS_FIFO_SIZE - npcm_smb_get_fifo_fullness(bus))) {
 		// write the data
 		if (bus->wr_ind < bus->wr_size) {
 			if (bus->PEC_use && (bus->wr_ind + 1 == bus->wr_size)) {
@@ -995,7 +1013,8 @@ static void npcm_smb_write_to_fifo_master(struct npcm_i2c *bus,
 }
 
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
-static void npcm_smb_write_to_fifo_slave(struct npcm_i2c *bus, u16 max_bytes_to_send)
+static void npcm_smb_write_to_fifo_slave(struct npcm_i2c *bus,
+					 u16 max_bytes_to_send)
 {
 	pdebug_lvl2(bus, "wr_fifo");
 	// Fill the FIFO, while the FIFO is not full and there are more bytes to
@@ -1004,16 +1023,19 @@ static void npcm_smb_write_to_fifo_slave(struct npcm_i2c *bus, u16 max_bytes_to_
 	npcm_smb_clear_tx_fifo(bus);
 	iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
 
-	while ((max_bytes_to_send--) && (SMBUS_FIFO_SIZE -
-					 npcm_smb_get_fifo_fullness(bus))) {
+	if (max_bytes_to_send == 0)
+		return;
+
+	while ((max_bytes_to_send--) &&
+	       (SMBUS_FIFO_SIZE - npcm_smb_get_fifo_fullness(bus))) {
 		// write the data
 		if (bus->slv_wr_size > 0) {
-			npcm_smb_wr_byte(bus,
-					 bus->slv_wr_buf[bus->slv_wr_ind % SMBUS_FIFO_SIZE]);
-			bus->slv_wr_ind = (bus->slv_wr_ind + 1) % SMBUS_FIFO_SIZE;
-			bus->slv_wr_size--;  // more bytes in fifo, less in cyclic buffer.
-		}
-		else
+			npcm_smb_wr_byte(bus, bus->slv_wr_buf[bus->slv_wr_ind %
+							      SMBUS_FIFO_SIZE]);
+			bus->slv_wr_ind =
+				(bus->slv_wr_ind + 1) % SMBUS_FIFO_SIZE;
+			bus->slv_wr_size--; // more bytes in fifo, less in cyclic buffer.
+		} else
 			break;
 	}
 
@@ -1034,10 +1056,8 @@ static void npcm_smb_set_fifo(struct npcm_i2c *bus, int nread, int nwrite)
 
 	// configure RX FIFO
 	if (nread > 0) {
-
 		rxf_ctl = min((u16)nread, (u16)SMBUS_FIFO_SIZE);
 
-
 		// set LAST bit. if LAST is set enxt FIFO packet is nacked at the end.
 
 		// regular read of less then buffer size:
@@ -1053,7 +1073,6 @@ static void npcm_smb_set_fifo(struct npcm_i2c *bus, int nread, int nwrite)
 
 		// set fifo size:
 		iowrite8(rxf_ctl, bus->reg + NPCM_SMBRXF_CTL);
-
 	}
 
 	// configure TX FIFO
@@ -1061,15 +1080,12 @@ static void npcm_smb_set_fifo(struct npcm_i2c *bus, int nread, int nwrite)
 		if (nwrite > SMBUS_FIFO_SIZE)
 			// data to send is more then FIFO size.
 			// Configure the FIFO int to be mid of FIFO.
-			iowrite8(SMBUS_FIFO_SIZE,
-				bus->reg + NPCM_SMBTXF_CTL);
+			iowrite8(SMBUS_FIFO_SIZE, bus->reg + NPCM_SMBTXF_CTL);
 		else
-			iowrite8(nwrite,
-				bus->reg + NPCM_SMBTXF_CTL);
+			iowrite8(nwrite, bus->reg + NPCM_SMBTXF_CTL);
 
 		npcm_smb_clear_tx_fifo(bus);
 	}
-
 }
 
 static void npcm_smb_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
@@ -1082,120 +1098,105 @@ static void npcm_smb_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
 	while (bytes_in_fifo--) {
 		npcm_smb_rd_byte(bus, &data);
 
-		if (bus->master_or_slave == SMB_MASTER) {
+		if (npcm_smb_is_master(bus)) {
 			if (bus->rd_ind < bus->rd_size) {
 				bus->rd_buf[bus->rd_ind++] = data;
-				if (bus->rd_ind == 1 && bus->read_block_use){
-
+				if (bus->rd_ind == 1 && bus->read_block_use) {
 					// First byte indicates length in block protocol
 					bus->rd_size = data;
 					pdebug_lvl2(bus, "blk rcv");
 				}
 			}
 		} else { // SMB_SLAVE:
+//printk("s fifo read\r\n");
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
-				bus->slv_rd_buf[bus->slv_rd_ind % SMBUS_FIFO_SIZE] = data;
-				bus->slv_rd_ind++;
-				if (bus->slv_rd_ind == 1 && bus->read_block_use)
-					// First byte indicates length in block protocol
-					bus->rd_size = data;
+			bus->slv_rd_buf[bus->slv_rd_ind % SMBUS_FIFO_SIZE] =
+				data;
+			bus->slv_rd_ind++;
+			if (bus->slv_rd_ind == 1 && bus->read_block_use)
+				// First byte indicates length in block protocol
+				bus->rd_size = data;
 
 #endif
 		}
 	}
 }
 
-
 static int npcm_smb_master_abort(struct npcm_i2c *bus)
 {
 	int ret = 0;
-	u8 data;
 	int len;
 
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_ABORT);
 
-	//pdebug(bus, " abort data 1 ");
+	pdebug_lvl2(bus, " abort data 1 ");
 
 	// Only current master is allowed to issue Stop Condition
 	if (npcm_smb_is_master(bus)) {
-		//pdebug(bus, " abort data 2 ");
+		pdebug_lvl2(bus, " abort data 2 ");
 		// stoping in the middle, not waing for interrupts anymore
-		npcm_smb_eob_int(bus,  false);
+		npcm_smb_eob_int(bus, false);
 
 		// Generate a STOP condition (after next wr\rd from fifo:
 		npcm_smb_master_stop(bus);
 
-		if (bus->operation == SMB_WRITE_OPER){
-			npcm_smb_set_fifo(bus, 0, 1);
-			// dummy write to FIFO:
-			npcm_smb_wr_byte(bus, 0xFF);
-			pdebug_lvl2(bus, " abort data wr");
-		}
-		else {
+		if ((NPCM_SMBST_XMIT & ioread8(bus->reg + NPCM_SMBST)) == 0) {
 			// gracefully abort read transaction
 			len = npcm_smb_get_fifo_fullness(bus);
 
 			if (len > 0)
 				npcm_smb_read_from_fifo(bus, len);
-			npcm_smb_set_fifo(bus, 1, 0);
-			npcm_smb_rd_byte(bus, &data);
-			pdebug_lvl2(bus, " abort data rd");
 		}
 
-		udelay(100); // TODO, replace with TO polling on BB bit.
+		npcm_smb_wait_for_bus_free(bus);
 
 		// Clear NEGACK, STASTR and BER bits
-		iowrite8(0xFF, bus->reg + NPCM_SMBST);
+		iowrite8(NPCM_SMBST_BER | NPCM_SMBST_NEGACK | NPCM_SMBST_STASTR,
+			 bus->reg + NPCM_SMBST);
 
 		pdebug_lvl2(bus, " abort data 3 ");
-
-		npcm_smb_reset(bus);
 	}
 
 	return ret;
 }
 
-
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
 
 static irqreturn_t npcm_i2c_bus_irq(int irq, void *dev_id);
 
-
-static int  npcm_smb_slave_enable_l(struct npcm_i2c *bus,
-			enum smb_addr addr_type, u8 addr, bool enable)
+static int npcm_smb_slave_enable_l(struct npcm_i2c *bus,
+				   enum smb_addr addr_type, u8 addr,
+				   bool enable)
 {
 	u8 SmbAddrX_Addr = FIELD_PREP(NPCM_SMBADDR_ADDR, addr) |
-		FIELD_PREP(NPCM_SMBADDR_SAEN, enable);
-
+			   FIELD_PREP(NPCM_SMBADDR_SAEN, enable);
 
 	pdebug_lvl2(bus, " slave enable ");
 	if (addr_type == SMB_GC_ADDR) {
 		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) &
-			~NPCM_SMBCTL1_GCMEN) |
-			FIELD_PREP(NPCM_SMBCTL1_GCMEN, enable),
-			bus->reg + NPCM_SMBCTL1);
+			  ~NPCM_SMBCTL1_GCMEN) |
+				 FIELD_PREP(NPCM_SMBCTL1_GCMEN, enable),
+			 bus->reg + NPCM_SMBCTL1);
 		return 0;
 	}
 	if (addr_type == SMB_ARP_ADDR) {
-
-		iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) &
-			~SMBCTL3_ARPMEN) |
-			FIELD_PREP(SMBCTL3_ARPMEN, enable),
-			bus->reg + NPCM_SMBCTL3);
+		iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_ARPMEN) |
+				 FIELD_PREP(SMBCTL3_ARPMEN, enable),
+			 bus->reg + NPCM_SMBCTL3);
 		return 0;
 	}
 	if (addr_type >= SMB_ARP_ADDR)
 		return -EFAULT;
 
 	// Disable ints and select bank 0 for address 3 to ...
-	if(addr_type > SMB_SLAVE_ADDR1)
+	if (addr_type > SMB_SLAVE_ADDR1)
 		npcm_smb_select_bank(bus, SMB_BANK_0);
 
 	// Set and enable the address
 	iowrite8(SmbAddrX_Addr, bus->reg + NPCM_SMBADDR[(int)addr_type]);
 
 	// return to bank 1 and enable ints (if needed)
-	if(addr_type > SMB_SLAVE_ADDR1)
+	if (addr_type > SMB_SLAVE_ADDR1)
 		npcm_smb_select_bank(bus, SMB_BANK_1);
 
 	pdebug_lvl2(bus, " slave enable done ");
@@ -1204,7 +1205,7 @@ static int  npcm_smb_slave_enable_l(struct npcm_i2c *bus,
 }
 
 static u8 npcm_smb_get_slave_addr_l(struct npcm_i2c *bus,
-				       enum smb_addr addr_type)
+				    enum smb_addr addr_type)
 {
 	u8 slaveAddress;
 
@@ -1218,7 +1219,7 @@ static u8 npcm_smb_get_slave_addr_l(struct npcm_i2c *bus,
 	// return to bank 1 and enable ints (if needed)
 	npcm_smb_select_bank(bus, SMB_BANK_1);
 
-	return  slaveAddress;
+	return slaveAddress;
 }
 
 #if defined(TODO_MULTI_SA) // poleg support up to 10 SA.
@@ -1235,8 +1236,8 @@ static bool npcm_smb_is_slave_addr_exist(struct npcm_i2c *bus, u8 addr)
 	return false;
 }
 
-static int  npcm_smb_add_slave_addr(struct npcm_i2c *bus,
-				       u8 slaveAddrToAssign, bool use_PEC)
+static int npcm_smb_add_slave_addr(struct npcm_i2c *bus, u8 slaveAddrToAssign,
+				   bool use_PEC)
 {
 	u16 i;
 	int ret = -EFAULT;
@@ -1245,15 +1246,14 @@ static int  npcm_smb_add_slave_addr(struct npcm_i2c *bus,
 	slaveAddrToAssign |= 0x80; //set the enable bit
 
 	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++) {
-		u8 currentSlaveAddr = npcm_smb_get_slave_addr_l(bus,
-							(enum smb_addr)i);
+		u8 currentSlaveAddr =
+			npcm_smb_get_slave_addr_l(bus, (enum smb_addr)i);
 		if (currentSlaveAddr == slaveAddrToAssign) {
 			ret = 0;
 			break;
-		}
-		else if ((currentSlaveAddr & 0x7F) == 0) {
-			ret = npcm_smb_slave_enable_l(bus,
-				(enum smb_addr)i, slaveAddrToAssign, true);
+		} else if ((currentSlaveAddr & 0x7F) == 0) {
+			ret = npcm_smb_slave_enable_l(bus, (enum smb_addr)i,
+						      slaveAddrToAssign, true);
 			break;
 		}
 	}
@@ -1267,8 +1267,8 @@ static int  npcm_smb_add_slave_addr(struct npcm_i2c *bus,
 	return ret;
 }
 
-static int  npcm_smb_get_current_slave_addr(struct npcm_i2c *bus,
-					       u8 *currSlaveAddr)
+static int npcm_smb_get_current_slave_addr(struct npcm_i2c *bus,
+					   u8 *currSlaveAddr)
 {
 	if (currSlaveAddr != NULL) {
 		*currSlaveAddr = bus->own_slave_addr;
@@ -1279,8 +1279,8 @@ static int  npcm_smb_get_current_slave_addr(struct npcm_i2c *bus,
 }
 #endif //TODO_MULTI_SA
 
-static int  npcm_smb_remove_slave_addr(struct npcm_i2c *bus,
-					  u8 slaveAddrToRemove)
+static int npcm_smb_remove_slave_addr(struct npcm_i2c *bus,
+				      u8 slaveAddrToRemove)
 {
 	int i;
 	slaveAddrToRemove |= 0x80; //Set the enable bit
@@ -1299,21 +1299,18 @@ static int  npcm_smb_remove_slave_addr(struct npcm_i2c *bus,
 	return 0;
 }
 
-#if defined(TODO_MULTI_SA)  // poleg support up to 10 SA.
-static int  npcm_smb_slave_global_call_enable(struct npcm_i2c *bus,
-						 bool enable)
+#if defined(TODO_MULTI_SA) // poleg support up to 10 SA.
+static int npcm_smb_slave_global_call_enable(struct npcm_i2c *bus, bool enable)
 {
 	return npcm_smb_slave_enable_l(bus, SMB_GC_ADDR, 0, enable);
 }
 
-static int  npcm_smb_slave_ARP_enable(struct npcm_i2c *bus, bool enable)
+static int npcm_smb_slave_ARP_enable(struct npcm_i2c *bus, bool enable)
 {
 	return npcm_smb_slave_enable_l(bus, SMB_ARP_ADDR, 0, enable);
 }
 #endif // TODO_MULTI_SA
 
-
-
 static int npcm_i2c_slave_get_wr_buf(struct npcm_i2c *bus)
 {
 	u8 value = 0;
@@ -1323,42 +1320,41 @@ static int npcm_i2c_slave_get_wr_buf(struct npcm_i2c *bus)
 	pdebug_lvl2(bus, "slv wr buf 1");
 
 	// fill a cyclic buffer
-	for (i = 0; i < SMBUS_FIFO_SIZE; i++){
+	for (i = 0; i < SMBUS_FIFO_SIZE; i++) {
 		if (bus->slv_wr_size >= SMBUS_FIFO_SIZE)
 			break;
 		i2c_slave_event(bus->slave, I2C_SLAVE_READ_REQUESTED, &value);
-		bus->slv_wr_buf[(bus->slv_wr_ind + bus->slv_wr_size) % SMBUS_FIFO_SIZE] = value;
+		bus->slv_wr_buf[(bus->slv_wr_ind + bus->slv_wr_size) %
+				SMBUS_FIFO_SIZE] = value;
 		bus->slv_wr_size++;
 		i2c_slave_event(bus->slave, I2C_SLAVE_READ_PROCESSED, &value);
-
-
 	}
 
 #ifdef _I2C_DEBUG_
 	printk("\nI2C%d get wr buf [%d / %d]\n\t  %x %x %x %x   %x %x %x %x    %x %x %x %x    %x %x %x %x\n",
-		bus->num, bus->slv_wr_ind, bus->slv_wr_size,
-		bus->slv_wr_buf[0], bus->slv_wr_buf[1], bus->slv_wr_buf[2], bus->slv_wr_buf[3],
-		bus->slv_wr_buf[4], bus->slv_wr_buf[5], bus->slv_wr_buf[6], bus->slv_wr_buf[7],
-		bus->slv_wr_buf[8], bus->slv_wr_buf[9], bus->slv_wr_buf[10], bus->slv_wr_buf[11],
-		bus->slv_wr_buf[12], bus->slv_wr_buf[13], bus->slv_wr_buf[14], bus->slv_wr_buf[15]);
+	       bus->num, bus->slv_wr_ind, bus->slv_wr_size, bus->slv_wr_buf[0],
+	       bus->slv_wr_buf[1], bus->slv_wr_buf[2], bus->slv_wr_buf[3],
+	       bus->slv_wr_buf[4], bus->slv_wr_buf[5], bus->slv_wr_buf[6],
+	       bus->slv_wr_buf[7], bus->slv_wr_buf[8], bus->slv_wr_buf[9],
+	       bus->slv_wr_buf[10], bus->slv_wr_buf[11], bus->slv_wr_buf[12],
+	       bus->slv_wr_buf[13], bus->slv_wr_buf[14], bus->slv_wr_buf[15]);
 #endif
 
 	return SMBUS_FIFO_SIZE - ret;
 }
 
-
 static void npcm_i2c_slave_send_rd_buf(struct npcm_i2c *bus)
 {
 	int i;
 
-	for (i = 0; i < bus->slv_rd_ind; i++){
+	for (i = 0; i < bus->slv_rd_ind; i++) {
 #ifdef _I2C_DEBUG_
 		printk("->   send 0x%x\n", bus->slv_rd_buf[i]);
 #endif
-		i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_RECEIVED, &bus->slv_rd_buf[i]);
+		i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_RECEIVED,
+				&bus->slv_rd_buf[i]);
 	}
 
-
 	// once we send bytes up, need to reset the counter of the wr buf
 	// got data from master (new offset in device), ignore wr fifo:
 	if (bus->slv_rd_ind) {
@@ -1367,25 +1363,22 @@ static void npcm_i2c_slave_send_rd_buf(struct npcm_i2c *bus)
 	}
 
 	bus->slv_rd_ind = 0;
-	bus->slv_rd_size = 32*1024;
+	bus->slv_rd_size = 32 * 1024;
 
+	npcm_smb_clear_fifo_int(bus);
 	npcm_smb_clear_rx_fifo(bus);
-
-
 }
 
-
-
 static bool npcm_smb_slave_start_receive(struct npcm_i2c *bus, u16 nread,
-					    u8 *read_data)
+					 u8 *read_data)
 {
 	pdebug_lvl2(bus, "start slv rcv");
 
 	// Update driver state
 	bus->state = SMB_OPER_STARTED;
-	bus->operation	 = SMB_READ_OPER;
-	bus->slv_rd_size	 = nread;
-	bus->slv_rd_ind	= 0;
+	bus->operation = SMB_READ_OPER;
+	bus->slv_rd_size = nread;
+	bus->slv_rd_ind = 0;
 
 	iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
 	iowrite8(SMBUS_FIFO_SIZE, bus->reg + NPCM_SMBRXF_CTL);
@@ -1397,7 +1390,7 @@ static bool npcm_smb_slave_start_receive(struct npcm_i2c *bus, u16 nread,
 }
 
 static bool npcm_smb_slave_start_xmit(struct npcm_i2c *bus, u16 nwrite,
-					 u8 *write_data)
+				      u8 *write_data)
 {
 	pdebug_lvl2(bus, "slv xmt ");
 
@@ -1410,24 +1403,20 @@ static bool npcm_smb_slave_start_xmit(struct npcm_i2c *bus, u16 nwrite,
 	// get the next buffer
 	npcm_i2c_slave_get_wr_buf(bus);
 
-	npcm_smb_clear_fifo_int(bus);
-
 	if (nwrite > 0) {
 		// Fill the FIFO with data
 		npcm_smb_write_to_fifo_slave(bus, nwrite);
 	}
 
-
 	return true;
 }
 
-
-
+#if 0
 static void npcm_smb_slave_abort(struct npcm_i2c *bus)
 {
 	volatile u8 temp;
 
-	pdebug(bus, "slv abort");
+	pdebug_lvl2(bus, "slv abort");
 	// Disable int.
 	npcm_smb_int_enable(bus, false);
 
@@ -1457,7 +1446,7 @@ static void npcm_smb_slave_abort(struct npcm_i2c *bus)
 	// Reset driver status
 	bus->state = SMB_IDLE;
 }
-
+#endif
 
 // currently slave IF only supports single byte operations.
 // in order to utilyze the npcm HW FIFO, the driver will ask for 16 bytes
@@ -1469,20 +1458,18 @@ static void npcm_smb_slave_abort(struct npcm_i2c *bus)
 // to the HW FIFO.
 // ret val: number of bytes read form the IF:
 
-
 static int npcm_i2c_slave_wr_buf_sync(struct npcm_i2c *bus)
 {
-
 	int left_in_fifo = FIELD_GET(NPCM_SMBTXF_STS_TX_BYTES,
-			ioread8(bus->reg + NPCM_SMBTXF_STS));
+				     ioread8(bus->reg + NPCM_SMBTXF_STS));
 
-
-	if(left_in_fifo >= SMBUS_FIFO_SIZE)
+	if (left_in_fifo >= SMBUS_FIFO_SIZE)
 		return left_in_fifo;
 
 	if (bus->slv_wr_size >= SMBUS_FIFO_SIZE) {
 #ifdef _I2C_DEBUG_
-		printk("wr buf full, [%d - %d] left %d",bus->slv_wr_ind, bus->slv_wr_size , left_in_fifo);
+		printk("wr buf full, [%d - %d] left %d", bus->slv_wr_ind,
+		       bus->slv_wr_size, left_in_fifo);
 #endif
 		return left_in_fifo; // you can't fill a cup which is already full
 	}
@@ -1494,37 +1481,31 @@ static int npcm_i2c_slave_wr_buf_sync(struct npcm_i2c *bus)
 	if (bus->slv_wr_ind < 0)
 		bus->slv_wr_ind += SMBUS_FIFO_SIZE;
 
-
 	return left_in_fifo;
 }
 
-
 static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 {
 	irqreturn_t ret = IRQ_NONE;
 
-	// spin_lock(&bus->lock);
 	// Slave: A negative acknowledge has occurred
-	if (FIELD_GET(NPCM_SMBST_NEGACK , ioread8(bus->reg + NPCM_SMBST))) {
-
+	if (FIELD_GET(NPCM_SMBST_NEGACK, ioread8(bus->reg + NPCM_SMBST))) {
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NACK);
 		bus->stop_ind = SMB_NACK_IND;
-
+		printk("s nack\r\n");
 		npcm_i2c_slave_wr_buf_sync(bus);
 		if (bus->fifo_use) {
 			// clear the FIFO
 			iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
 				 bus->reg + NPCM_SMBFIF_CTS);
 		}
-		//npcm_smb_clear_rx_fifo(bus);
-		//npcm_smb_clear_tx_fifo(bus);
-
 
 		pdebug_lvl2(bus, "int NACK slave");
 
 		// In slave write operation, NACK is OK, otherwise it is a problem
 		bus->stop_ind = SMB_NO_STATUS_IND;
 		bus->operation = SMB_NO_OPER;
+		bus->own_slave_addr = 0xFF;
 
 		// Slave has to wait for SMB_STOP to decide this is the end of the transaction.
 		// Therefore transaction is not yet considered as done
@@ -1533,42 +1514,47 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 		ret = IRQ_HANDLED;
 	}
 
-
-
 	// Slave mode: a Bus Error has been identified
 	if (FIELD_GET(NPCM_SMBST_BER, ioread8(bus->reg + NPCM_SMBST))) {
 		// Check whether bus arbitration or Start or Stop during data
 		// xfer bus arbitration problem should not result in recovery
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_BER);
 		bus->stop_ind = SMB_BUS_ERR_IND;
-		iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
-				 bus->reg + NPCM_SMBFIF_CTS);
+		iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO, bus->reg + NPCM_SMBFIF_CTS);
 		npcm_smb_init_params(bus);
+		//printk("s ber\r\n");
 		bus->state = SMB_IDLE;
+
+		// in BER case, we are not sure if SMBST.MASTER is accurate:
+		if (completion_done(&bus->cmd_complete) == false) {
+			bus->cmd_err = -EIO;
+			complete(&bus->cmd_complete);
+		}
+		bus->own_slave_addr = 0xFF;
 		iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
-		ret =  IRQ_HANDLED;
+		ret = IRQ_HANDLED;
 	}
 
-
 	// A Slave Stop Condition has been identified
-	if (FIELD_GET(NPCM_SMBST_SLVSTP , ioread8(bus->reg + NPCM_SMBST))) {
-
+	if (FIELD_GET(NPCM_SMBST_SLVSTP, ioread8(bus->reg + NPCM_SMBST))) {
 		pdebug_lvl2(bus, "int slv stop");
-
+		//printk("s stop\r\n");
 		bus->stop_ind = SMB_SLAVE_DONE_IND;
 
 		if (bus->operation == SMB_READ_OPER) {
-			npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+			npcm_smb_read_from_fifo(
+				bus, npcm_smb_get_fifo_fullness(bus));
 
 			// if PEC is used and PEC is correct
 			if ((bus->PEC_use == true) &&
-			    (npcm_smb_get_PEC(bus) != 0)){
+			    (npcm_smb_get_PEC(bus) != 0)) {
 				bus->stop_ind = SMB_SLAVE_PEC_ERR_IND;
 			}
 		}
 
 		// Slave done transmitting or receiving
-		npcm_i2c_slave_send_rd_buf(bus); // if the buffer is empty nothing will be sent
+		npcm_i2c_slave_send_rd_buf(
+			bus); // if the buffer is empty nothing will be sent
 
 		bus->stop_ind = SMB_NO_STATUS_IND;
 
@@ -1578,6 +1564,7 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 		bus->int_cnt = 0;
 		bus->event_log_prev = bus->event_log;
 		bus->event_log = 0;
+		bus->own_slave_addr = 0xFF;
 		pdebug_lvl2(bus, "SLV_DONE");
 
 		i2c_slave_event(bus->slave, I2C_SLAVE_STOP, 0);
@@ -1598,18 +1585,19 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 
 		bus->state = SMB_IDLE;
 
-		ret =  IRQ_HANDLED;
+		ret = IRQ_HANDLED;
 	}
 
 	// When a start condition occurred, the Rx-FIFO was not empty
 	if (bus->fifo_use && FIELD_GET(NPCM_SMBFIF_CTS_SLVRSTR,
 				       ioread8(bus->reg + NPCM_SMBFIF_CTS))) {
 		pdebug_lvl2(bus, "int slave restart");
-
+		//printk("s resta\r\n");
 		bus->stop_ind = SMB_SLAVE_RESTART_IND;
 
-		if (bus->operation == SMB_READ_OPER){
-			npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+		if (bus->operation == SMB_READ_OPER) {
+			npcm_smb_read_from_fifo(
+				bus, npcm_smb_get_fifo_fullness(bus));
 		}
 
 		bus->operation = SMB_WRITE_OPER;
@@ -1617,27 +1605,29 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 		iowrite8(0, bus->reg + NPCM_SMBRXF_CTL);
 
 		pdebug_lvl2(bus, "CB: slv restart");
-		npcm_i2c_slave_send_rd_buf(bus); // send up whatever is on the buffer.
+		npcm_i2c_slave_send_rd_buf(
+			bus); // send up whatever is on the buffer.
 
 		iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO | NPCM_SMBFIF_CTS_SLVRSTR |
-			 NPCM_SMBFIF_CTS_RXF_TXE, bus->reg + NPCM_SMBFIF_CTS);
+				 NPCM_SMBFIF_CTS_RXF_TXE,
+			 bus->reg + NPCM_SMBFIF_CTS);
 
 		// Slave got an address match with direction bit set so it
 		//	should transmit data
 		// Write till the master will NACK
-		npcm_smb_slave_start_xmit(bus, bus->adap.quirks->max_write_len, bus->slv_wr_buf);
+		npcm_smb_slave_start_xmit(bus, bus->adap.quirks->max_write_len,
+					  bus->slv_wr_buf);
 
-		ret =  IRQ_HANDLED;
+		ret = IRQ_HANDLED;
 	}
 
-
 	// A Slave Address Match has been identified
-	if (FIELD_GET(NPCM_SMBST_NMATCH , ioread8(bus->reg + NPCM_SMBST))) {
+	if (FIELD_GET(NPCM_SMBST_NMATCH, ioread8(bus->reg + NPCM_SMBST))) {
 		u8 info = 0;
 
 		pdebug_lvl2(bus, "int slave match");
 
-
+		//printk("s match\r\n");
 		// Address match automatically implies slave mode
 		bus->master_or_slave = SMB_SLAVE;
 
@@ -1647,21 +1637,28 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 		iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
 		iowrite8(SMBUS_FIFO_SIZE, bus->reg + NPCM_SMBRXF_CTL);
 
-
-		if (FIELD_GET(NPCM_SMBST_XMIT, ioread8(bus->reg + NPCM_SMBST))) {
+		if (FIELD_GET(NPCM_SMBST_XMIT,
+			      ioread8(bus->reg + NPCM_SMBST))) {
 			bus->operation = SMB_WRITE_OPER;
 			bus->stop_ind = SMB_SLAVE_XMIT_IND;
 			iowrite8(NPCM_SMBST_XMIT, bus->reg + NPCM_SMBST);
 		} else {
-			i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_REQUESTED, &info);
+			i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_REQUESTED,
+					&info);
 			bus->operation = SMB_READ_OPER;
 			bus->stop_ind = SMB_SLAVE_RCV_IND;
 		}
 
-		if (bus->state == SMB_IDLE) {
+		if (bus->own_slave_addr == 0xFF) { // unknown address
 			// Check which type of address match
-			if (FIELD_GET(NPCM_SMBCST_MATCH , ioread8(bus->reg + NPCM_SMBCST))) {
-				u16 address_match = ((ioread8(bus->reg + NPCM_SMBCST3) & 0x7) << 7) | (ioread8(bus->reg + NPCM_SMBCST2) & 0x7F);
+			if (FIELD_GET(NPCM_SMBCST_MATCH,
+				      ioread8(bus->reg + NPCM_SMBCST))) {
+				u16 address_match =
+					((ioread8(bus->reg + NPCM_SMBCST3) &
+					  0x7)
+					 << 7) |
+					(ioread8(bus->reg + NPCM_SMBCST2) &
+					 0x7F);
 				info = 0;
 
 				while (address_match) {
@@ -1670,27 +1667,37 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 					info++;
 					address_match = address_match >> 1;
 				}
-				bus->own_slave_addr = FIELD_GET(NPCM_SMBADDR_ADDR, npcm_smb_get_slave_addr_l(bus, (enum smb_addr)info));
+				bus->own_slave_addr = FIELD_GET(
+					NPCM_SMBADDR_ADDR,
+					npcm_smb_get_slave_addr_l(
+						bus, (enum smb_addr)info));
 				if (bus->PEC_mask & BIT(info)) {
 					bus->PEC_use = true;
 					bus->crc_data = 0;
 					if (bus->stop_ind == SMB_SLAVE_XMIT_IND)
-						npcm_smb_calc_PEC(bus, (bus->own_slave_addr & 0x7F) << 1 | 1);
+						npcm_smb_calc_PEC(
+							bus,
+							(bus->own_slave_addr &
+							 0x7F) << 1 |
+								1);
 					else
-						npcm_smb_calc_PEC(bus, (bus->own_slave_addr & 0x7F) << 1);
+						npcm_smb_calc_PEC(
+							bus,
+							(bus->own_slave_addr &
+							 0x7F) << 1);
 				} else
 					bus->PEC_use = false;
 			} else {
-				if (FIELD_GET(NPCM_SMBCST_GCMATCH , ioread8(bus->reg + NPCM_SMBCST))) {
-					info = (u8)SMB_GC_ADDR;
+				if (FIELD_GET(NPCM_SMBCST_GCMATCH,
+					      ioread8(bus->reg + NPCM_SMBCST))) {
 					bus->own_slave_addr = 0;
 				} else {
-					if (FIELD_GET(NPCM_SMBCST_ARPMATCH , ioread8(bus->reg + NPCM_SMBCST))) {
-						info = (u8)SMB_ARP_ADDR;
+					if (FIELD_GET(NPCM_SMBCST_ARPMATCH,
+						      ioread8(bus->reg +
+							      NPCM_SMBCST))) {
 						bus->own_slave_addr = 0x61;
 					}
 				}
-				// printk("slave match addr 0x%x", bus->own_slave_addr);
 			}
 		} else {
 			//  Slave match can happen in two options:
@@ -1698,95 +1705,65 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 			//  2. Start, SA, read , data , restart, SA, read,  ... ( slave read in fragmented mode)
 			//  3. Start, SA, write, data, restart, SA, read, .. ( regular write-read mode)
 			if ((bus->state == SMB_OPER_STARTED &&
-				bus->operation == SMB_READ_OPER && bus->stop_ind == SMB_SLAVE_XMIT_IND) ||
-				(bus->stop_ind == SMB_SLAVE_RCV_IND)){
+			     bus->operation == SMB_READ_OPER &&
+			     bus->stop_ind == SMB_SLAVE_XMIT_IND) ||
+			    (bus->stop_ind == SMB_SLAVE_RCV_IND)) {
 				// slave transmit after slave receive w/o Slave Stop implies repeated start
 				bus->stop_ind = SMB_SLAVE_RESTART_IND;
-				info = (u8)(bus->slv_rd_ind);
-				npcm_smb_calc_PEC(bus, (bus->own_slave_addr & 0x7F) << 1 | 1);
-				pdebug_lvl2(bus, "slave Sr ");
+				npcm_smb_calc_PEC(
+					bus,
+					(bus->own_slave_addr & 0x7F) << 1 | 1);
 			}
 		}
 
 		bus->state = SMB_SLAVE_MATCH;
 
-		if (FIELD_GET(NPCM_SMBST_XMIT, ioread8(bus->reg + NPCM_SMBST))) {
-
+		if (FIELD_GET(NPCM_SMBST_XMIT,
+			      ioread8(bus->reg + NPCM_SMBST))) {
+			//printk("s xmit\r\n");
 			// Slave got an address match with direction bit set so it
 			//	should transmit data
 			// Write till the master will NACK
-			npcm_smb_slave_start_xmit(bus, bus->adap.quirks->max_write_len, bus->slv_wr_buf);
+			npcm_smb_slave_start_xmit(
+				bus, bus->adap.quirks->max_write_len,
+				bus->slv_wr_buf);
 		} else {
-
 			// Slave got an address match with direction bit clear so it
 			//	should receive data.
 			// this module does not support saying no to bytes. it will always ACK.
 			pdebug_lvl2(bus, "CB: slv rcv");
+			//printk("s rcv\r\n");
 			npcm_i2c_slave_send_rd_buf(bus);
-
-			npcm_smb_slave_start_receive(bus, bus->adap.quirks->max_read_len, bus->slv_rd_buf);
+			npcm_smb_slave_start_receive(
+				bus, bus->adap.quirks->max_read_len,
+				bus->slv_rd_buf);
 		}
 
-
 		iowrite8(NPCM_SMBST_NMATCH, bus->reg + NPCM_SMBST);
-
-#ifdef SMB_RECOVERY_SUPPORT
-
-		// By now, SMB operation state should have been changed from MATCH to SMB_OPER_STARTED.
-		// If state hasn't been changed already, this may suggest that the SMB slave is not ready to
-		// transmit or receive data.
-		//
-		// In addition, when using FIFO, NMATCH bit is cleared only when moving to SMB_OPER_STARTED state.
-		// If NMATCH is not cleared, we would get an endless SMB int.
-		// Therefore, Abort the slave, such that SMB HW and state machine return to a default, functional
-		// state.
-		if (bus->state == SMB_SLAVE_MATCH) {
-			npcm_smb_slave_abort(bus);
-			return IRQ_HANDLED;
-		}
-
-		// Slave abort data
-		// if the SMBus's status is not match current status reg of XMIT
-		// the Slave device will enter dead-lock and stall bus forever
-		// Add this check rule to avoid this condition
-		if ((bus->operation == SMB_READ_OPER  &&
-			bus->stop_ind == SMB_SLAVE_XMIT_IND) ||
-			(bus->operation == SMB_WRITE_OPER
-			&& bus->stop_ind == SMB_SLAVE_RCV_IND)) {
-			npcm_smb_slave_abort(bus);
-			return IRQ_HANDLED;
-		}
-#endif
-		ret =  IRQ_HANDLED;
-
-		// If none of the above - BER should occur
+		ret = IRQ_HANDLED;
 	}
 
-
-
 	// Slave SDA status is set - transmit or receive, slave
 	if (FIELD_GET(NPCM_SMBST_SDAST, ioread8(bus->reg + NPCM_SMBST)) ||
-	    (bus->fifo_use   &&
-	    (npcm_smb_tx_fifo_empty(bus) || npcm_smb_rx_fifo_full(bus)))) {
-
+	    (bus->fifo_use &&
+	     (npcm_smb_tx_fifo_empty(bus) || npcm_smb_rx_fifo_full(bus)))) {
 		pdebug_lvl2(bus, "SDA slave set");
-
+		//printk("s sda\r\n");
 		// Perform slave read. No need to distinguish between last byte and the rest of the bytes.
-		if ((NPCM_SMBST_XMIT & ioread8(bus->reg + NPCM_SMBST)) == 0 ){
+		if ((NPCM_SMBST_XMIT & ioread8(bus->reg + NPCM_SMBST)) == 0) {
 			bus->operation = SMB_READ_OPER;
-			npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
-
-			npcm_smb_clear_fifo_int(bus);
-
+			npcm_smb_read_from_fifo(
+				bus, npcm_smb_get_fifo_fullness(bus));
+			//printk("s sda-r\r\n");
 			bus->stop_ind = SMB_SLAVE_RCV_IND;
 
 			// Slave got an address match with direction bit clear so it
 			//	should receive data.
 			// this module does not support saying no to bytes. it will always ACK.
-			pdebug_lvl2(bus, "CB: slv rcv");
 			npcm_i2c_slave_send_rd_buf(bus);
-
-			npcm_smb_slave_start_receive(bus, bus->adap.quirks->max_read_len, bus->slv_rd_buf);
+			npcm_smb_slave_start_receive(
+				bus, bus->adap.quirks->max_read_len,
+				bus->slv_rd_buf);
 
 		}
 		// Perform slave write.
@@ -1794,29 +1771,28 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 			// Slave got an address match with direction bit set so it
 			//	should transmit data
 			// Write till the master will NACK
-			npcm_smb_slave_start_xmit(bus, bus->adap.quirks->max_write_len, bus->slv_wr_buf);
+			//printk("s sda-w\r\n");
+			npcm_smb_slave_start_xmit(
+				bus, bus->adap.quirks->max_write_len,
+				bus->slv_wr_buf);
 		}
 
+		iowrite8(NPCM_SMBST_SDAST, bus->reg + NPCM_SMBST);
 
-		iowrite8( NPCM_SMBST_SDAST, bus->reg + NPCM_SMBST);
-
-		ret =  IRQ_HANDLED;
+		ret = IRQ_HANDLED;
 	} //SDAST
 
-
-	//spin_unlock(&bus->lock);
 	return ret;
 }
 
-
-static int  npcm_i2c_reg_slave(struct i2c_client *client)
+static int npcm_i2c_reg_slave(struct i2c_client *client)
 {
 	unsigned long lock_flags;
 	struct npcm_i2c *bus = i2c_get_adapdata(client->adapter);
 
 	bus->slave = client;
 
-	if (!bus->slave)	{
+	if (!bus->slave) {
 		return -EINVAL;
 	}
 
@@ -1829,8 +1805,8 @@ static int  npcm_i2c_reg_slave(struct i2c_client *client)
 
 	bus->own_slave_addr = client->addr;
 
-	pr_err("I2C%d register slave SA=0x%x, PEC=%d\n", bus->num,
-			client->addr, bus->PEC_use);
+	pr_err("I2C%d register slave SA=0x%x, PEC=%d\n", bus->num, client->addr,
+	       bus->PEC_use);
 
 	npcm_smb_select_bank(bus, SMB_BANK_0);
 
@@ -1839,7 +1815,7 @@ static int  npcm_i2c_reg_slave(struct i2c_client *client)
 
 	npcm_smb_slave_enable_l(bus, SMB_SLAVE_ADDR1, client->addr, true);
 
-	 // return to bank 1 and enable ints (if needed)
+	// return to bank 1 and enable ints (if needed)
 	npcm_smb_select_bank(bus, SMB_BANK_1);
 
 	npcm_smb_clear_fifo_int(bus);
@@ -1851,7 +1827,7 @@ static int  npcm_i2c_reg_slave(struct i2c_client *client)
 	return 0;
 }
 
-static int  npcm_i2c_unreg_slave(struct i2c_client *client)
+static int npcm_i2c_unreg_slave(struct i2c_client *client)
 {
 	struct npcm_i2c *bus = client->adapter->algo_data;
 	unsigned long lock_flags;
@@ -1862,7 +1838,6 @@ static int  npcm_i2c_unreg_slave(struct i2c_client *client)
 		return -EINVAL;
 	}
 
-
 	// Turn off slave mode.
 	npcm_smb_remove_slave_addr(bus, client->addr);
 
@@ -1873,7 +1848,6 @@ static int  npcm_i2c_unreg_slave(struct i2c_client *client)
 }
 #endif // CONFIG_I2C_SLAVE
 
-
 static void npcm_smb_master_fifo_read(struct npcm_i2c *bus)
 {
 	int rcount;
@@ -1892,14 +1866,12 @@ static void npcm_smb_master_fifo_read(struct npcm_i2c *bus)
 	if (rcount < (2 * SMBUS_FIFO_SIZE) && rcount > SMBUS_FIFO_SIZE)
 		fifo_bytes = (u8)(rcount - SMBUS_FIFO_SIZE);
 
-
 	if ((rcount - fifo_bytes) <= 0) {
 		// last bytes are about to be read - end of transaction.
 		// Stop should be set before reading last byte.
 
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ4);
 
-
 		if (npcm_smb_get_PEC(bus) != 0)
 			ind = SMB_MASTER_PEC_ERR_IND;
 
@@ -1912,12 +1884,10 @@ static void npcm_smb_master_fifo_read(struct npcm_i2c *bus)
 		npcm_smb_read_from_fifo(bus, fifo_bytes);
 
 	} else {
-
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ3);
 		npcm_smb_read_from_fifo(bus, fifo_bytes);
 		rcount = bus->rd_size - bus->rd_ind;
 		npcm_smb_set_fifo(bus, rcount, -1);
-
 	}
 }
 
@@ -1934,10 +1904,10 @@ static void npcm_smb_int_master_handler_write(struct npcm_i2c *bus)
 	if (bus->wr_ind == bus->wr_size) {
 		pdebug_lvl2(bus, "last wr");
 		if (bus->fifo_use && npcm_smb_get_fifo_fullness(bus) > 0)
-	// No more bytes to send (to add to the FIFO), however the FIFO is not
-	// empty yet. It is still in the middle of tx. Currently there's nothing
-	// to do except for waiting to the end of the tx.
-	// We will get an int when the FIFO will get empty.
+			// No more bytes to send (to add to the FIFO), however the FIFO is not
+			// empty yet. It is still in the middle of tx. Currently there's nothing
+			// to do except for waiting to the end of the tx.
+			// We will get an int when the FIFO will get empty.
 			return;
 
 		if (bus->rd_size == 0) {
@@ -1957,8 +1927,8 @@ static void npcm_smb_int_master_handler_write(struct npcm_i2c *bus)
 			// restart & send slave address
 			if (bus->PEC_use && !bus->read_block_use &&
 			    !npcm_smb_is_quick(bus))
-			    // PEC is used but the protocol is not block read
-			    // then we add extra bytes for PEC support
+				// PEC is used but the protocol is not block read
+				// then we add extra bytes for PEC support
 				bus->rd_size += 1;
 
 			npcm_smb_set_fifo(bus, bus->rd_size, -1);
@@ -1968,20 +1938,17 @@ static void npcm_smb_int_master_handler_write(struct npcm_i2c *bus)
 
 			if (bus->rd_size == 1)
 
-	// Receiving one byte only - stall after successful completion of send
-	// address byte. If we NACK here, and slave doesn't ACK the address, we
-	// might unintentionally NACK the next multi-byte read
+				// Receiving one byte only - stall after successful completion of send
+				// address byte. If we NACK here, and slave doesn't ACK the address, we
+				// might unintentionally NACK the next multi-byte read
 
 				npcm_smb_stall_after_start(bus, true);
 
 			// Next int will occur on read
 			bus->operation = SMB_READ_OPER;
 
-
-
 			// send the slave address in read direction
 			npcm_smb_wr_byte(bus, bus->dest_addr | 0x1);
-
 		}
 	} else {
 		if (bus->PEC_use && !npcm_smb_is_quick(bus))
@@ -2032,7 +1999,6 @@ static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 		// in block protocol first byte is the size
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ1);
 		if (bus->read_block_use) {
-
 			// first byte in block protocol is the size:
 			npcm_smb_rd_byte(bus, &data);
 
@@ -2055,8 +2021,8 @@ static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 			// clear RX FIFO interrupt status:
 			if (bus->fifo_use) {
 				iowrite8(NPCM_SMBFIF_CTS_RXF_TXE |
-					 ioread8(bus->reg +
-						 NPCM_SMBFIF_CTS),
+						 ioread8(bus->reg +
+							 NPCM_SMBFIF_CTS),
 					 bus->reg + NPCM_SMBFIF_CTS);
 				//npcm_smb_clear_fifo_int(bus);
 			}
@@ -2066,41 +2032,42 @@ static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 			// Reset stall
 			npcm_smb_stall_after_start(bus, false);
 		} else {
-
 			npcm_smb_clear_tx_fifo(bus);
 			npcm_smb_master_fifo_read(bus);
-
 		}
 
 	} else {
-
 		if (bus->rd_size == block_extra_bytes_size &&
 		    bus->read_block_use) {
-		    	bus->state = SMB_STOP_PENDING;
+			bus->state = SMB_STOP_PENDING;
 			bus->stop_ind = SMB_BLOCK_BYTES_ERR_IND;
 			npcm_smb_eob_int(bus, true);
 			npcm_smb_master_stop(bus);
-			npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+			npcm_smb_read_from_fifo(
+				bus, npcm_smb_get_fifo_fullness(bus));
 
 		} else {
 			NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ2);
 			npcm_smb_master_fifo_read(bus);
 		}
-
 	}
-
 }
 
 static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 {
 	irqreturn_t ret = IRQ_NONE;
+	u8 smbfif_cts;
+
 	// A negative acknowledge has occurred
 	if (FIELD_GET(NPCM_SMBST_NEGACK, ioread8(bus->reg + NPCM_SMBST))) {
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NACK);
 		if (bus->fifo_use) {
 			// if there are still untransmitted bytes in TX FIFO
 			// reduce them from wr_ind
-
+			if (3 == bus->num) {
+				//printk("m nack:0x%x\r\n", ioread8(bus->reg + NPCM_SMBST));
+				//printk("m cst:0x%x\r\n", ioread8(bus->reg + NPCM_SMBCST));
+			}
 			if (bus->operation == SMB_WRITE_OPER)
 				bus->wr_ind -= npcm_smb_get_fifo_fullness(bus);
 			// clear the FIFO
@@ -2123,8 +2090,9 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 		// Then a Stop condition is sent.
 		iowrite8(NPCM_SMBST_NEGACK, bus->reg + NPCM_SMBST);
 		npcm_smb_callback(bus, bus->stop_ind, bus->wr_ind);
-		ret =  IRQ_HANDLED;
+		ret = IRQ_HANDLED;
 
+		return ret;
 	}
 
 	// Master mode: a Bus Error has been identified
@@ -2132,6 +2100,10 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 		// Check whether bus arbitration or Start or Stop during data
 		// xfer bus arbitration problem should not result in recovery
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_BER);
+		pdebug_lvl2(bus, "BER_M");
+		if (3 == bus->num) {
+			//printk("m ber\r\n");
+		}
 		if (npcm_smb_is_master(bus)) {
 			// Only current master is allowed to issue stop
 			bus->stop_ind = SMB_BUS_ERR_IND;
@@ -2141,7 +2113,7 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 			if (bus->retry_count-- > 1) {
 				// Perform a retry (generate a start condition)
 				// as soon as the SMBus is free
-				pdebug(bus, "retry-BER");
+				pdebug_lvl2(bus, "retry-BER");
 				iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
 				npcm_smb_master_start(bus);
 				return IRQ_HANDLED;
@@ -2151,7 +2123,7 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 		bus->state = SMB_IDLE;
 		bus->stop_ind = SMB_BUS_ERR_IND;
 		npcm_smb_callback(bus, bus->stop_ind, npcm_smb_get_index(bus));
-		ret =  IRQ_HANDLED;
+		ret = IRQ_HANDLED;
 	}
 
 	// A Master End of Busy (meaning Stop Condition happened)
@@ -2161,18 +2133,23 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 	    (FIELD_GET(NPCM_SMBCST3_EO_BUSY,
 		       ioread8(bus->reg + NPCM_SMBCST3)))) {
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_EOB);
+		if (3 == bus->num) {
+			//printk("m eob\r\n");
+		}
 		pdebug_lvl2(bus, "EOB  ");
 		npcm_smb_eob_int(bus, false);
 		bus->state = SMB_IDLE;
 		npcm_smb_callback(bus, bus->stop_ind, bus->rd_ind);
-		ret =  IRQ_HANDLED;
+		ret = IRQ_HANDLED;
 	}
 
 	// Address sent and requested stall occurred (Master mode)
 	if (FIELD_GET(NPCM_SMBST_STASTR, ioread8(bus->reg + NPCM_SMBST))) {
 		pdebug_lvl2(bus, "stall");
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_STALL);
-
+		if (3 == bus->num) {
+			//printk("m stall\r\n");
+		}
 		// Check for Quick Command SMBus protocol
 		if (npcm_smb_is_quick(bus)) {
 			// Update status
@@ -2181,7 +2158,7 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 			npcm_smb_eob_int(bus, true);
 			npcm_smb_master_stop(bus);
 
-		} else if ((bus->rd_size == 1) && !bus->read_block_use){
+		} else if ((bus->rd_size == 1) && !bus->read_block_use) {
 			// Receiving one byte only - set NACK after ensuring
 			// slave ACKed the address byte
 			npcm_smb_nack(bus);
@@ -2193,74 +2170,98 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 		// Clear stall only after setting STOP
 		iowrite8(NPCM_SMBST_STASTR, bus->reg + NPCM_SMBST);
 
-		ret =  IRQ_HANDLED;
+		ret = IRQ_HANDLED;
 	}
 
 	// SDA status is set - transmit or receive, master
 	if (FIELD_GET(NPCM_SMBST_SDAST, ioread8(bus->reg + NPCM_SMBST)) ||
 	    (bus->fifo_use &&
-	    (npcm_smb_tx_fifo_empty(bus) || npcm_smb_rx_fifo_full(bus)))) {
+	     (npcm_smb_tx_fifo_empty(bus) || npcm_smb_rx_fifo_full(bus)))) {
 		// Status Bit is cleared by writing to or reading from SDA
 		// (depending on current direction)
-		switch (bus->state) {
-		// Handle unsuccessful bus mastership
-		case SMB_IDLE:
-			bus->stop_ind = SMB_WAKE_UP_IND;
-			npcm_smb_master_abort(bus);
-			return IRQ_HANDLED;
+		if (3 == bus->num) {
+			//printk("state: 0x%x\r\n",bus->state);
+		}
 
-		case SMB_MASTER_START:
+		// Send address:
+		if (bus->state == SMB_IDLE) {
 			if (npcm_smb_is_master(bus)) {
-				u8 addr_byte = bus->dest_addr;
+				bus->stop_ind = SMB_WAKE_UP_IND;
 
 				bus->crc_data = 0;
-				if (npcm_smb_is_quick(bus)) {
+
+				// test stall on start
+				if (npcm_smb_is_quick(bus) ||
+				    (bus->read_block_use == true)) {
 					// Need to stall after successful
 					// completion of sending address byte
 					npcm_smb_stall_after_start(bus, true);
-					bus->operation = SMB_WRITE_OPER;
-				} else if (bus->wr_size == 0) {
-					// Set direction to Read
-					addr_byte |= (u8)0x1;
-					bus->operation = SMB_READ_OPER;
 				} else {
-					bus->operation = SMB_WRITE_OPER;
+					npcm_smb_stall_after_start(bus, false);
 				}
-
-	// Receiving one byte only - stall after successful completion of
-	// sending address byte. If we NACK here, and slave doesn't ACK the
-	// address, we might unintentionally NACK the next multi-byte read
+				// Receiving one byte only - stall after successful completion of
+				// sending address byte. If we NACK here, and slave doesn't ACK the
+				// address, we might unintentionally NACK the next multi-byte read
 				if (bus->wr_size == 0 && bus->rd_size == 1)
 					npcm_smb_stall_after_start(bus, true);
 
-				// Write the address to the bus
+#if 0
+				// Initiate SMBus master transaction
+				// Generate a Start condition on the SMBus
+
+				// select bank 1 for FIFO regs
+				npcm_smb_select_bank(bus, SMB_BANK_1);
+
+				smbfif_cts = ioread8(bus->reg + NPCM_SMBFIF_CTS);
+
+				// clear FIFO and relevant status bits.
+				iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
+					 NPCM_SMBFIF_CTS_CLR_FIFO,
+					 bus->reg + NPCM_SMBFIF_CTS);
+
+				// and enable it
+				iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
+					 NPCM_SMBFIF_CTS_RXF_TXE,
+					 bus->reg + NPCM_SMBFIF_CTS);
+
+				// Configure the FIFO
+				//threshold according to the needed # of bytes to read.
+				npcm_smb_set_fifo(bus, bus->rd_size, bus->wr_size);
+#endif
 				bus->state = SMB_OPER_STARTED;
-				npcm_smb_wr_byte(bus, addr_byte);
-			} else {
-				dev_err(bus->dev,
-					"SDA, bus%d is not master, wr %d 0x%x...\n",
-					bus->num, bus->wr_size,
-					bus->wr_buf[0]);
+
+				if (npcm_smb_is_quick(bus) ||
+				    (bus->wr_size > 0)) {
+					if (3 == bus->num) {
+						//printk("m w-a:0x%x\r\n", bus->dest_addr);
+					}
+					npcm_smb_wr_byte(bus, bus->dest_addr);
+				} else
+					npcm_smb_wr_byte(bus,
+							 bus->dest_addr | 0x01);
 			}
-			break;
 
+			return IRQ_HANDLED;
+
+		}
 		// SDA status is set - transmit or receive: Handle master mode
-		case SMB_OPER_STARTED:
-			if ((NPCM_SMBST_XMIT & ioread8(bus->reg + NPCM_SMBST)) == 0 ){
+		else {
+			if ((NPCM_SMBST_XMIT &
+			     ioread8(bus->reg + NPCM_SMBST)) == 0) {
+				if (3 == bus->num) {
+					//printk("m rd\r\n");
+				}
 				bus->operation = SMB_READ_OPER;
 				npcm_smb_int_master_handler_read(bus);
-			}
-			else {
+			} else {
+				if (3 == bus->num) {
+					//printk("m wr\r\n");
+				}
 				bus->operation = SMB_WRITE_OPER;
 				npcm_smb_int_master_handler_write(bus);
 			}
-
-			break;
-		default:
-			dev_err(bus->dev, "i2c%d master sda err on state machine\n",
-				bus->num);
 		}
-		ret =  IRQ_HANDLED;
+		ret = IRQ_HANDLED;
 	}
 
 	return ret;
@@ -2268,8 +2269,8 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 
 static int npcm_smb_recovery(struct i2c_adapter *_adap)
 {
-	u8   iter = 27;	  // Allow one byte to be sent by the Slave
-	u16  timeout;
+	u8 iter = 27; // Allow one byte to be sent by the Slave
+	u16 timeout;
 	bool done = false;
 	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
 
@@ -2331,13 +2332,13 @@ static int npcm_smb_recovery(struct i2c_adapter *_adap)
 static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 			      u32 bus_freq)
 {
-	u32  k1 = 0;
-	u32  k2 = 0;
-	u8   dbnct = 0;
-	u32  sclfrq = 0;
-	u8   hldt = 7;
+	u32 k1 = 0;
+	u32 k2 = 0;
+	u8 dbnct = 0;
+	u32 sclfrq = 0;
+	u8 hldt = 7;
 	bool fast_mode = false;
-	u32  src_clk_freq; // in KHz
+	u32 src_clk_freq; // in KHz
 
 	src_clk_freq = bus->apb_clk / 1000;
 
@@ -2361,14 +2362,15 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 
 		if ((mode == SMB_MASTER && src_clk_freq < 7500) ||
 		    (mode == SMB_SLAVE && src_clk_freq < 10000))
-		  // 400KHZ cannot be supported for master core clock < 7.5 MHZ
-		  // or slave core clock < 10 MHZ
+			// 400KHZ cannot be supported for master core clock < 7.5 MHZ
+			// or slave core clock < 10 MHZ
 			return false;
 
 		// Master or Slave with frequency > 25 MHZ
 		if (mode == SMB_MASTER || src_clk_freq > 25000) {
 			hldt = (u8)__KERNEL_DIV_ROUND_UP(src_clk_freq * 300,
-							 1000000) + 7;
+							 1000000) +
+			       7;
 			if (mode == SMB_MASTER) {
 				k1 = __KERNEL_DIV_ROUND_UP(src_clk_freq * 1600,
 							   1000000);
@@ -2391,16 +2393,19 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 		fast_mode = true;
 
 		if ((mode == SMB_MASTER && src_clk_freq < 15000) ||
-		    (mode == SMB_SLAVE	&& src_clk_freq < 24000))
-		// 1MHZ cannot be supported for master core clock < 15 MHZ
-		// or slave core clock < 24 MHZ
+		    (mode == SMB_SLAVE && src_clk_freq < 24000))
+			// 1MHZ cannot be supported for master core clock < 15 MHZ
+			// or slave core clock < 24 MHZ
 			return false;
 
 		if (mode == SMB_MASTER) {
 			k1 = round_up((__KERNEL_DIV_ROUND_UP(src_clk_freq * 620,
-							     1000000)), 2);
+							     1000000)),
+				      2);
 			k2 = round_up((__KERNEL_DIV_ROUND_UP(src_clk_freq * 380,
-							     1000000) + 1), 2);
+							     1000000) +
+				       1),
+				      2);
 			if (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX ||
 			    k2 < SCLFRQ_MIN || k2 > SCLFRQ_MAX) {
 				return false;
@@ -2413,9 +2418,10 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 			// SDA hold time:  (HLDT-7) * T(CLK) >= 120
 			// HLDT = 120/T(CLK) + 7 = 120 * FREQ(CLK) + 7
 			hldt = (u8)__KERNEL_DIV_ROUND_UP(src_clk_freq * 120,
-							 1000000) + 7;
+							 1000000) +
+			       7;
 
-		// Slave with frequency 24-40 MHZ
+			// Slave with frequency 24-40 MHZ
 		} else {
 			hldt = 7;
 			dbnct = 2;
@@ -2427,16 +2433,16 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 		return false;
 
 	// After clock parameters calculation update the reg
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL2)
-		& ~SMBCTL2_SCLFRQ6_0) | FIELD_PREP(SMBCTL2_SCLFRQ6_0,
-		sclfrq & 0x7F), bus->reg + NPCM_SMBCTL2);
+	iowrite8((ioread8(bus->reg + NPCM_SMBCTL2) & ~SMBCTL2_SCLFRQ6_0) |
+			 FIELD_PREP(SMBCTL2_SCLFRQ6_0, sclfrq & 0x7F),
+		 bus->reg + NPCM_SMBCTL2);
 
 	iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_SCLFRQ8_7) |
-		 FIELD_PREP(SMBCTL3_SCLFRQ8_7, (sclfrq >> 7) & 0x3),
+			 FIELD_PREP(SMBCTL3_SCLFRQ8_7, (sclfrq >> 7) & 0x3),
 		 bus->reg + NPCM_SMBCTL3);
 
 	iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_400K_MODE) |
-		 FIELD_PREP(SMBCTL3_400K_MODE, fast_mode),
+			 FIELD_PREP(SMBCTL3_400K_MODE, fast_mode),
 		 bus->reg + NPCM_SMBCTL3);
 
 	// Select Bank 0 to access NPCM_SMBCTL4/NPCM_SMBCTL5
@@ -2452,19 +2458,21 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 			iowrite8((u8)k2 / 2, bus->reg + NPCM_SMBSCLHT);
 		} else { // DBNCT is relevant for slave mode only
 			iowrite8((ioread8(bus->reg + NPCM_SMBCTL5) &
-				 ~SMBCTL5_DBNCT) |
-				 FIELD_PREP(SMBCTL5_DBNCT, dbnct),
+				  ~SMBCTL5_DBNCT) |
+					 FIELD_PREP(SMBCTL5_DBNCT, dbnct),
 				 bus->reg + NPCM_SMBCTL5);
 		}
 	}
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL4) & ~SMBCTL4_HLDT)
-		 | FIELD_PREP(SMBCTL4_HLDT, hldt), bus->reg + NPCM_SMBCTL4);
+	iowrite8((ioread8(bus->reg + NPCM_SMBCTL4) & ~SMBCTL4_HLDT) |
+			 FIELD_PREP(SMBCTL4_HLDT, hldt),
+		 bus->reg + NPCM_SMBCTL4);
 
 	// Return to Bank 1, and stay there by default:
 	npcm_smb_select_bank(bus, SMB_BANK_1);
 
-	dev_dbg(bus->dev, "k1 = %d k2 = %d dbnct = %d sclfrq = %d hldt = %d src_clk_freq %d fast_mode %d\n",
+	dev_dbg(bus->dev,
+		"k1 = %d k2 = %d dbnct = %d sclfrq = %d hldt = %d src_clk_freq %d fast_mode %d\n",
 		k1, k2, dbnct, sclfrq, hldt, src_clk_freq, fast_mode);
 
 	return true;
@@ -2486,7 +2494,8 @@ static bool npcm_smb_init_module(struct npcm_i2c *bus, enum smb_mode mode,
 		bus->fifo_use = true;
 		npcm_smb_select_bank(bus, SMB_BANK_0);
 		iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTL) |
-			 NPCM_SMBFIF_CTL_FIFO_EN, bus->reg + NPCM_SMBFIF_CTL);
+				 NPCM_SMBFIF_CTL_FIFO_EN,
+			 bus->reg + NPCM_SMBFIF_CTL);
 		npcm_smb_select_bank(bus, SMB_BANK_1);
 	} else {
 		bus->fifo_use = false;
@@ -2505,10 +2514,13 @@ static bool npcm_smb_init_module(struct npcm_i2c *bus, enum smb_mode mode,
 
 	// Enable SMB int and New Address Match int source
 	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_NMINTE) &
-		 ~NPCM_SMBCTL1_RWS_FIELDS,
+			 ~NPCM_SMBCTL1_RWS_FIELDS,
 		 bus->reg + NPCM_SMBCTL1);
 
 	npcm_smb_int_enable(bus, true);
+
+	npcm_smb_reset(bus);
+
 	return true;
 }
 
@@ -2523,18 +2535,16 @@ static int __npcm_i2c_init(struct npcm_i2c *bus, struct platform_device *pdev)
 	bus->int_time_stamp = 0;
 	bus->slave = NULL;
 
-	ret = of_property_read_u32(pdev->dev.of_node,
-				   "bus-frequency", &clk_freq);
+	ret = of_property_read_u32(pdev->dev.of_node, "bus-frequency",
+				   &clk_freq);
 	if (ret < 0) {
-		dev_err(&pdev->dev,
-			"Could not read bus-frequency property\n");
+		dev_err(&pdev->dev, "Could not read bus-frequency property\n");
 		clk_freq = 100000;
 	}
 
 	ret = npcm_smb_init_module(bus, SMB_MASTER, clk_freq / 1000);
 	if (!ret) {
-		dev_err(&pdev->dev,
-			"npcm_smb_init_module() failed\n");
+		dev_err(&pdev->dev, "npcm_smb_init_module() failed\n");
 		return -1;
 	}
 
@@ -2550,39 +2560,52 @@ static irqreturn_t npcm_i2c_bus_irq(int irq, void *dev_id)
 
 	bus->int_cnt++;
 
-	if(npcm_smb_is_master(bus))
+	//spin_lock(&bus->lock);
+
+	if (npcm_smb_is_master(bus))
 		bus->master_or_slave = SMB_MASTER;
 
-	if (bus->master_or_slave == SMB_MASTER)	{
- 		bus->int_time_stamp = jiffies;
+	if (bus->master_or_slave == SMB_MASTER) {
+		bus->int_time_stamp = jiffies;
 		ret = npcm_smb_int_master_handler(bus);
-		if (ret == IRQ_HANDLED)
+		if (ret == IRQ_HANDLED) {
+			//spin_unlock(&bus->lock);
 			return ret;
+		}
 	}
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
 	if (bus->slave) {
 		bus->master_or_slave = SMB_SLAVE;
-		return npcm_smb_int_slave_handler(bus);
+		ret = npcm_smb_int_slave_handler(bus);
+		if (ret == IRQ_HANDLED) {
+			//spin_unlock(&bus->lock);
+			return ret;
+		}
 	}
 #endif
 
+	//spin_unlock(&bus->lock);
+
 	return IRQ_HANDLED;
 }
 
-static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus,
-				       u8 slave_addr, u16 nwrite, u16 nread,
-				       u8 *write_data, u8 *read_data,
-				       bool use_PEC, bool use_read_block)
+static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus, u8 slave_addr,
+				       u16 nwrite, u16 nread, u8 *write_data,
+				       u8 *read_data, bool use_PEC,
+				       bool use_read_block)
 {
-	u8 smbfif_cts;
-
 	// Allow only if bus is not busy
 	if (bus->state != SMB_IDLE) {
-		dev_err(bus->dev, "\tbus%d->state != SMB_IDLE\n", bus->num);
+		pdebug_lvl2(bus, "xmit not IDLE\n");
+		if (3 == bus->num) {
+			//printk("xmit not idle 1!!!\r\n");
+		}
 		return false;
 	}
-
-	bus->dest_addr = (u8)(slave_addr << 1);// Translate 7bit to 8bit format
+	if (3 == bus->num) {
+		//printk("bus->state: 0x%x\r\n", bus->state);
+	}
+	bus->dest_addr = (u8)(slave_addr << 1); // Translate 7bit to 8bit format
 	bus->wr_buf = write_data;
 	bus->wr_size = nwrite;
 	bus->wr_ind = 0;
@@ -2591,7 +2614,7 @@ static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus,
 	bus->rd_ind = 0;
 	bus->PEC_use = use_PEC;
 	bus->PEC_mask = 0;
-	bus->retry_count = 0 ; // SMB_RETRY_MAX_COUNT;
+	bus->retry_count = 0; // SMB_RETRY_MAX_COUNT;
 	bus->read_block_use = use_read_block;
 
 	if (nread > 0)
@@ -2599,10 +2622,12 @@ static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus,
 	else
 		bus->operation = SMB_WRITE_OPER;
 
-
-	// Initiate SMBus master transaction
-	// Generate a Start condition on the SMBus
+	bus->int_cnt = 0;
+	bus->event_log = 0;
+	pdebug_lvl2(bus, "xmit ");
+#if 1
 	if (bus->fifo_use) {
+		u8 smbfif_cts;
 		// select bank 1 for FIFO regs
 		npcm_smb_select_bank(bus, SMB_BANK_1);
 
@@ -2610,36 +2635,38 @@ static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus,
 
 		// clear FIFO and relevant status bits.
 		iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
-			 NPCM_SMBFIF_CTS_CLR_FIFO,
+				 NPCM_SMBFIF_CTS_CLR_FIFO,
 			 bus->reg + NPCM_SMBFIF_CTS);
 
 		// and enable it
 		iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
-			 NPCM_SMBFIF_CTS_RXF_TXE,
+				 NPCM_SMBFIF_CTS_RXF_TXE,
 			 bus->reg + NPCM_SMBFIF_CTS);
 
 		// Configure the FIFO
 		//threshold according to the needed # of bytes to read.
 		npcm_smb_set_fifo(bus, nread, nwrite);
-
 	}
-
-	bus->int_cnt = 0;
-	bus->event_log = 0;
-	pdebug_lvl2(bus, "xmit ");
-
-	// Update driver state
+#endif
 	// Allow only if bus is not busy
 	if (bus->state != SMB_IDLE) {
-		dev_err(bus->dev, "\tbus%d->state(2) != SMB_IDLE\n", bus->num);
+		if (3 == bus->num) {
+			//printk("xmit not idle!!!\r\n");
+		}
+		pdebug(bus, "xmit not IDLE\n");
 		return false;
 	}
+	bus->state = SMB_IDLE;
+	// bus->master_or_slave = SMB_MASTER;
 
-	bus->state = SMB_MASTER_START;
-	bus->master_or_slave = SMB_MASTER;
+	if (npcm_smb_wait_for_bus_free(bus) == false)
+		return false;
 
+	npcm_smb_stall_after_start(bus, true);
 	npcm_smb_master_start(bus);
-
+	if (3 == bus->num) {
+		//printk("xmit done\r\n");
+	}
 	return true;
 }
 
@@ -2654,22 +2681,22 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	u8 slave_addr;
 	int ret = 0;
 	int timeout = bus->adap.timeout;
-	unsigned long timeout1;
 	bool read_block = false;
 
-
-
 	if (num > 2 || num < 1) {
 		pr_err("I2C command not supported, num of msgs = %d\n", num);
 		return -EINVAL;
 	}
 
+	spin_lock_irqsave(&bus->lock, flags);
+
 	msg0 = &msgs[0];
 	slave_addr = msg0->addr;
 	if (msg0->flags & I2C_M_RD) { // read
 		if (num == 2) {
 			pr_err(" num = 2 but first msg is rd instead of wr\n");
-			return -EINVAL;
+			ret = -EINVAL;
+			goto xfer_end;
 		}
 		nwrite = 0;
 		write_data = NULL;
@@ -2691,11 +2718,13 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 			if (slave_addr != msg1->addr) {
 				pr_err("SA==%02x but msg1->addr == %02x\n",
 				       slave_addr, msg1->addr);
-				return -EINVAL;
+				ret = -EINVAL;
+				goto xfer_end;
 			}
 			if ((msg1->flags & I2C_M_RD) == 0) {
 				pr_err("num = 2 but both msg are write.\n");
-				return -EINVAL;
+				ret = -EINVAL;
+				goto xfer_end;
 			}
 			if (msg1->flags & I2C_M_RECV_LEN) {
 				nread = 1;
@@ -2712,73 +2741,68 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	bus->msgs = msgs;
 	bus->msgs_num = num;
 
-	if(nread == 0 && nwrite == 0){
+	if (nread == 0 && nwrite == 0) {
 		timeout = msecs_to_jiffies(1);
-	}
-	else if (read_block)
-		timeout = usecs_to_jiffies((2 + I2C_SMBUS_BLOCK_MAX + nwrite)*1300);
+	} else if (read_block)
+		timeout = usecs_to_jiffies((2 + I2C_SMBUS_BLOCK_MAX + nwrite) *
+					   1300);
 	else {
 		// resonable assumption which leaves time for clock stretching.
-		timeout = usecs_to_jiffies((2 + nread + nwrite)*1300);
+		timeout = usecs_to_jiffies((2 + nread + nwrite) * 1300);
 #if 1 //ifdef _I2C_DEBUG_
 		timeout = timeout * 1000;
 #endif
-
 	}
 
-	if (nwrite >= 32 * 1024 ||  nread >= 32 * 1024) {
+	if (nwrite >= 32 * 1024 || nread >= 32 * 1024) {
 		pr_err("i2c%d buffer too big\n", bus->num);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto xfer_end;
 	}
 
-	timeout1 = jiffies + bus->adap.timeout;
-	while (((ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BB) == 1) ||
-		(bus->state != SMB_IDLE)){
-		if (time_after(jiffies, timeout1)) {
-			pdebug(bus, "ETIMEDOUT");
-			return -ETIMEDOUT;
-		}
-		cpu_relax();
+	if (npcm_smb_wait_for_bus_free(bus) == false) {
+		ret = bus->cmd_err;
+		goto xfer_end;
 	}
 
-	spin_lock_irqsave(&bus->lock, flags);
-
 	npcm_smb_init_params(bus);
 
 	reinit_completion(&bus->cmd_complete);
 
 	if (npcm_smb_master_start_xmit(bus, slave_addr, nwrite, nread,
-				       write_data, read_data, 0, read_block) == false)
+				       write_data, read_data, 0,
+				       read_block) == false)
 		ret = -(EBUSY);
 
 	if (ret != -(EBUSY)) {
 		time_left = wait_for_completion_timeout(&bus->cmd_complete,
 							timeout);
 
-		if (time_left == 0 && bus->cmd_err == -EPERM) {
+		if (time_left == 0) {
 			NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_TO);
 			pdebug_lvl2(bus, "xfer TO");
 
-			if (bus->master_or_slave == SMB_MASTER){
+			if (bus->master_or_slave == SMB_MASTER) {
 				// timeout while bus is busy:
-				npcm_smb_master_abort(bus); // don't stop in the middle.
+				npcm_smb_master_abort(
+					bus); // don't stop in the middle.
 
 				// Reset driver status
 				bus->state = SMB_IDLE;
 			}
-
-			ret = -ETIMEDOUT;
-		} else {
-			ret = bus->cmd_err;
 		}
+		ret = bus->cmd_err;
+
 	} else {
 #if defined(CONFIG_I2C_DEBUG_BUS)
 		pdebug_lvl2(bus, "busy");
 #endif
 	}
 
+xfer_end:
 	bus->msgs = NULL;
 	bus->msgs_num = 0;
+
 	spin_unlock_irqrestore(&bus->lock, flags);
 
 	// If nothing went wrong, return number of messages xferred.
@@ -2790,7 +2814,8 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 
 static u32 npcm_i2c_functionality(struct i2c_adapter *adap)
 {
-	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SLAVE;
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA |
+	       I2C_FUNC_SLAVE;
 }
 
 static const struct i2c_adapter_quirks npcm_i2c_quirks = {
@@ -2800,13 +2825,12 @@ static const struct i2c_adapter_quirks npcm_i2c_quirks = {
 	.flags = I2C_AQ_COMB_WRITE_THEN_READ
 };
 
-
 static const struct i2c_algorithm npcm_i2c_algo = {
 	.master_xfer = npcm_i2c_master_xfer,
 	.functionality = npcm_i2c_functionality,
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
-	.reg_slave	= npcm_i2c_reg_slave,
-	.unreg_slave	= npcm_i2c_unreg_slave,
+	.reg_slave = npcm_i2c_reg_slave,
+	.unreg_slave = npcm_i2c_unreg_slave,
 #endif // CONFIG_I2C_SLAVE
 };
 
@@ -2816,7 +2840,7 @@ static struct i2c_bus_recovery_info npcm_i2c_recovery = {
 	.get_sda = npcm_smb_get_SDA,
 };
 
-static int  npcm_i2c_probe_bus(struct platform_device *pdev)
+static int npcm_i2c_probe_bus(struct platform_device *pdev)
 {
 	struct npcm_i2c *bus;
 	struct i2c_adapter *adap;
@@ -2828,14 +2852,15 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 	bus = devm_kzalloc(&pdev->dev, sizeof(*bus), GFP_KERNEL);
 	if (!bus)
 		return -ENOMEM;
-
+	buss[bus->adap.nr] = bus;
+	printk("i2c driver debug version.\n");
 #ifdef CONFIG_OF
 	num = of_alias_get_id(pdev->dev.of_node, "i2c");
 	bus->num = num;
 	i2c_clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(i2c_clk)) {
 		pr_err(" I2C probe failed: can't read clk.\n");
-		return	-EPROBE_DEFER;
+		return -EPROBE_DEFER;
 	}
 	bus->apb_clk = clk_get_rate(i2c_clk);
 	dev_dbg(bus->dev, "I2C APB clock is %d\n", bus->apb_clk);
@@ -2895,7 +2920,7 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 	dev_dbg(bus->dev, "irq = %d\n", bus->irq);
 
 	ret = devm_request_irq(&pdev->dev, bus->irq, npcm_i2c_bus_irq, 0,
-			  dev_name(&pdev->dev), (void *)bus);
+			       dev_name(&pdev->dev), (void *)bus);
 
 	if (ret) {
 		dev_err(&pdev->dev, "I2C%d: request_irq fail\n", bus->num);
@@ -2904,22 +2929,23 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 
 	i2c_set_adapdata(adap, bus);
 
-
 	snprintf(bus->adap.name, sizeof(bus->adap.name), "Nuvoton i2c");
 
 	ret = i2c_add_numbered_adapter(&bus->adap);
 	if (ret < 0) {
-		dev_err(&pdev->dev, "I2C%d: i2c_add_numbered_adapter fail\n", bus->num);
+		dev_err(&pdev->dev, "I2C%d: i2c_add_numbered_adapter fail\n",
+			bus->num);
 		return ret;
 	}
 
 	platform_set_drvdata(pdev, bus);
 	pr_info("i2c bus %d registered\n", bus->adap.nr);
+	buss[bus->adap.nr] = bus;
 
 	return 0;
 }
 
-static int  npcm_i2c_remove_bus(struct platform_device *pdev)
+static int npcm_i2c_remove_bus(struct platform_device *pdev)
 {
 	unsigned long lock_flags;
 	struct npcm_i2c *bus = platform_get_drvdata(pdev);
@@ -2933,19 +2959,20 @@ static int  npcm_i2c_remove_bus(struct platform_device *pdev)
 }
 
 static const struct of_device_id npcm_i2c_bus_of_table[] = {
-	{ .compatible = "nuvoton,npcm750-i2c", },
+	{
+		.compatible = "nuvoton,npcm750-i2c",
+	},
 	{},
 };
 MODULE_DEVICE_TABLE(of, npcm_i2c_bus_of_table);
 
-static struct platform_driver npcm_i2c_bus_driver = {
-	.probe = npcm_i2c_probe_bus,
-	.remove = npcm_i2c_remove_bus,
-	.driver = {
-		.name = "nuvoton-i2c",
-		.of_match_table = npcm_i2c_bus_of_table,
-	}
-};
+static struct platform_driver npcm_i2c_bus_driver =
+	{ .probe = npcm_i2c_probe_bus,
+	  .remove = npcm_i2c_remove_bus,
+	  .driver = {
+		  .name = "nuvoton-i2c",
+		  .of_match_table = npcm_i2c_bus_of_table,
+	  } };
 module_platform_driver(npcm_i2c_bus_driver);
 
 MODULE_AUTHOR("Avi Fishman <avi.fishman@gmail.com>");
@@ -2953,4 +2980,3 @@ MODULE_AUTHOR("Tali Perry <tali.perry@nuvoton.com>");
 MODULE_DESCRIPTION("Nuvoton I2C Bus Driver");
 MODULE_LICENSE("GPL v2");
 MODULE_VERSION(I2C_VERSION);
-
-- 
2.21.0

