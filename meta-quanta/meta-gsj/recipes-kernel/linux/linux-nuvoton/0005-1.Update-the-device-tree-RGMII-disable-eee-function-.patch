From 43d0812fa300441b31758892372218e9349f2c88 Mon Sep 17 00:00:00 2001
From: Fran Hsu <Fran.Hsu@quantatw.com>
Date: Wed, 11 Sep 2019 16:32:43 +0800
Subject: [PATCH] 1.Update the device tree: RGMII disable eee function, RMII
 remove the phy-mode setting. 2.Commit i2c driver 0.0.42 and a workaround of
 200us delay for power brick reset issue.

Signed-off-by: Fran Hsu <Fran.Hsu@quantatw.com>
---
 arch/arm/boot/dts/nuvoton-npcm730-gsj.dts |    5 +-
 drivers/i2c/busses/i2c-npcm7xx.c          | 1474 +++++++++------------
 2 files changed, 622 insertions(+), 857 deletions(-)

diff --git a/arch/arm/boot/dts/nuvoton-npcm730-gsj.dts b/arch/arm/boot/dts/nuvoton-npcm730-gsj.dts
index 801ed73d962c..8c05c3b159d3 100644
--- a/arch/arm/boot/dts/nuvoton-npcm730-gsj.dts
+++ b/arch/arm/boot/dts/nuvoton-npcm730-gsj.dts
@@ -5,7 +5,7 @@
 #include "nuvoton-npcm730.dtsi"
 #include "nuvoton-npcm730-gsj-gpio.dtsi"
 / {
-	model = "Quanta GSJ Board (Device Tree v12)";
+	model = "Quanta GSJ Board (Device Tree v15)";
 	compatible = "nuvoton,npcm750";
 
 	aliases {
@@ -38,6 +38,7 @@
 		gmac0: eth@f0802000 {
 			phy-mode = "rgmii-id";
 			status = "okay";
+			snps,eee-force-disable;
 		};
 
 		mc: memory-controller@f0824000 {
@@ -47,7 +48,7 @@
 		};
 
 		emc0: eth@f0825000 {
-			phy-mode = "rmii";
+			// phy-mode = "rmii";
 			use-ncsi;
 			status = "okay";
 		};
diff --git a/drivers/i2c/busses/i2c-npcm7xx.c b/drivers/i2c/busses/i2c-npcm7xx.c
index 6b9862c91768..0f586a28be1c 100644
--- a/drivers/i2c/busses/i2c-npcm7xx.c
+++ b/drivers/i2c/busses/i2c-npcm7xx.c
@@ -20,9 +20,12 @@
 #include <linux/regmap.h>
 #include <linux/jiffies.h>
 
-#define I2C_VERSION "0.0.21"
+#define I2C_VERSION "0.0.42.1"
 
 //#define _I2C_DEBUG_
+#define BUS_TO_DEBUG -1
+#define POWER_BRICK_BUS 11
+#define POWER_BRICK_ADDRES 0x36
 
 enum smb_mode { SMB_SLAVE = 1, SMB_MASTER };
 
@@ -41,9 +44,7 @@ enum smb_state_ind {
 	SMB_NACK_IND = 8,
 	SMB_BUS_ERR_IND = 9,
 	SMB_WAKE_UP_IND = 10,
-	SMB_MASTER_PEC_ERR_IND = 11,
 	SMB_BLOCK_BYTES_ERR_IND = 12,
-	SMB_SLAVE_PEC_ERR_IND = 13,
 	SMB_SLAVE_RCV_MISSING_DATA_IND = 14,
 };
 
@@ -63,7 +64,7 @@ enum smb_state {
 	SMB_STOP_PENDING
 };
 
-// Module supports setting multiple own slave addresses:
+// Module supports setting multiple own slave addresses
 enum smb_addr {
 	SMB_SLAVE_ADDR1 = 0,
 	SMB_SLAVE_ADDR2,
@@ -111,7 +112,7 @@ static struct regmap *clk_regmap;
 #define NPCM_SMBADDR6 0x016
 #define NPCM_SMBADDR10 0x017
 
-// SMBADDR array: because the addr regs are sprincled all over the address space
+// SMBADDR array: because the addr regs are sprinkled all over the address space
 const int NPCM_SMBADDR[10] = { NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 			       NPCM_SMBADDR4, NPCM_SMBADDR5, NPCM_SMBADDR6,
 			       NPCM_SMBADDR7, NPCM_SMBADDR8, NPCM_SMBADDR9,
@@ -166,7 +167,7 @@ const int NPCM_SMBADDR[10] = { NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 #define NPCM_SMBCTL1_RWS_FIELDS                                                \
 	(NPCM_SMBCTL1_START | NPCM_SMBCTL1_STOP | NPCM_SMBCTL1_ACK)
 // NPCM_SMBADDR reg fields
-#define NPCM_SMBADDR_ADDR GENMASK(6, 0)
+#define NPCM_SMBADDR_A GENMASK(6, 0)
 #define NPCM_SMBADDR_SAEN BIT(7)
 
 // NPCM_SMBCTL2 reg fields
@@ -212,11 +213,7 @@ const int NPCM_SMBADDR[10] = { NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 #define NPCM_SMBFIF_CTS_SLVRSTR BIT(7)
 
 // NPCM_SMBTXF_CTL reg fields
-#ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBTXF_CTL_TX_THR GENMASK(5, 0)
-#else
 #define NPCM_SMBTXF_CTL_TX_THR GENMASK(4, 0)
-#endif
 #define NPCM_SMBTXF_CTL_THR_TXIE BIT(6)
 
 // NPCM_SMBT_OUT reg fields
@@ -225,39 +222,23 @@ const int NPCM_SMBADDR[10] = { NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 #define NPCM_SMBT_OUT_T_OUTST BIT(7)
 
 // NPCM_SMBTXF_STS reg fields
-#ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBTXF_STS_TX_BYTES GENMASK(5, 0)
-#else
 #define NPCM_SMBTXF_STS_TX_BYTES GENMASK(4, 0)
-#endif
 #define NPCM_SMBTXF_STS_TX_THST BIT(6)
 
 // NPCM_SMBRXF_STS reg fields
-#ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBRXF_STS_RX_BYTES GENMASK(5, 0)
-#else
 #define NPCM_SMBRXF_STS_RX_BYTES GENMASK(4, 0)
-#endif
 #define NPCM_SMBRXF_STS_RX_THST BIT(6)
 
 // NPCM_SMBFIF_CTL reg fields
 #define NPCM_SMBFIF_CTL_FIFO_EN BIT(4)
 
 // NPCM_SMBRXF_CTL reg fields
-// Note: on the next HW version of this module, this HW is about to switch to
-//	 32 bytes FIFO. This size will be set using a config.
-//	 on current version 16 bytes FIFO is set using a define
-#ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBRXF_CTL_RX_THR GENMASK(5, 0)
-#define NPCM_SMBRXF_CTL_LAST_PEC BIT(7)
-#define SMBUS_FIFO_SIZE 32
-#else
 #define NPCM_SMBRXF_CTL_RX_THR GENMASK(4, 0)
 #define NPCM_SMBRXF_CTL_LAST_PEC BIT(5)
-#define SMBUS_FIFO_SIZE 16
-#endif
 #define NPCM_SMBRXF_CTL_THR_RXIE BIT(6)
 
+#define SMBUS_FIFO_SIZE 16
+
 // SMB_VER reg fields
 #define SMB_VER_VERSION GENMASK(6, 0)
 #define SMB_VER_FIFO_EN BIT(7)
@@ -265,8 +246,8 @@ const int NPCM_SMBADDR[10] = { NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
 // stall/stuck timeout
 const unsigned int DEFAULT_STALL_COUNT = 25;
 
-// Data abort timeout
-const unsigned int ABORT_TIMEOUT = 10000;
+// retries in a loop
+const unsigned int RETRIES_NUM = 10000;
 
 // SMBus spec. values in KHZ
 const unsigned int SMBUS_FREQ_MIN = 10;
@@ -283,11 +264,8 @@ const unsigned int SCLFRQ_MAX = 511;
 #define SCLFRQ_0_TO_6 GENMASK(6, 0)
 #define SCLFRQ_7_TO_8 GENMASK(8, 7)
 
-// SMB Maximum Retry Trials (on Bus Arbitration Loss)
-const unsigned int SMB_RETRY_MAX_COUNT = 2;
 const unsigned int SMB_NUM_OF_ADDR = 10;
 
-// for logging:
 #define NPCM_I2C_EVENT_START BIT(0)
 #define NPCM_I2C_EVENT_STOP BIT(1)
 #define NPCM_I2C_EVENT_ABORT BIT(2)
@@ -308,14 +286,14 @@ const unsigned int SMB_NUM_OF_ADDR = 10;
 #define NPCM_I2C_EVENT_READ3 BIT(14)
 #define NPCM_I2C_EVENT_READ4 BIT(15)
 
+#define NPCM_I2C_EVENT_NMATCH_SLV BIT(16)
+#define NPCM_I2C_EVENT_NMATCH_MSTR BIT(17)
+#define NPCM_I2C_EVENT_BER_SLV BIT(18)
+
 #define NPCM_I2C_EVENT_LOG(event) (bus->event_log |= event)
 
 #define SMB_RECOVERY_SUPPORT
 
-// slave mode: if end device reads more data than available, ask issuer or
-// request for more data:
-#define SMB_WRAP_AROUND_BUFFER
-
 // Status of one SMBus module
 struct npcm_i2c {
 	struct i2c_adapter adap;
@@ -348,14 +326,13 @@ struct npcm_i2c {
 	//		0: do not use PEC for this address
 	u16 PEC_mask;
 	bool PEC_use;
-	u8 crc_data;
 	bool read_block_use;
-	u8 retry_count;
 	u8 int_cnt;
 	u32 event_log;
 	u32 event_log_prev;
 	u32 clk_period_us;
 	unsigned long int_time_stamp;
+	u32 xmits;
 
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
 	u8 own_slave_addr;
@@ -368,7 +345,7 @@ struct npcm_i2c {
 	// NACK on read will be once reached to bus->adap->quirks->max_read_len
 	// sending a NACK whever the backend requests for it is not supported.
 
-	// This module can be master and slave at the same time. seperate ptrs
+	// This module can be master and slave at the same time. separate ptrs
 	// and counters:
 	int slv_rd_size;
 	int slv_rd_ind;
@@ -396,20 +373,16 @@ static inline void npcm_smb_select_bank(struct npcm_i2c *bus,
 //------------------
 static inline bool npcm_smb_is_quick(struct npcm_i2c *bus);
 
-static struct npcm_i2c *buss[16];
-
-static void pdebug(struct npcm_i2c *bus, char str[20])
+static void pdebug(struct npcm_i2c *bus, u32 line, const char *str)
 {
 	char str2[65];
 	char *s = str2;
 	int rd_size, wr_size, rd_ind, wr_ind;
-#ifndef _I2C_DEBUG_
-	//return; // for debug, remove this line..
-#endif
-	//if(npcm_smb_is_quick(bus))
-	//	return;
 
-	//if(bus->num != 1) return;
+	//if (npcm_smb_is_quick(bus))
+	//	return;
+	if (bus->num != BUS_TO_DEBUG)
+		return;
 
 	if (bus->master_or_slave == SMB_MASTER) {
 		rd_size = bus->rd_size;
@@ -427,8 +400,16 @@ static void pdebug(struct npcm_i2c *bus, char str[20])
 #endif
 	}
 
+	if (bus->read_block_use) {
+		s += sprintf(s, "B ");
+	}
+
+	if (bus->PEC_use) {
+		s += sprintf(s, "P ");
+	}
+
 	s += sprintf(s, "bus%d ", bus->num);
-	s += sprintf(s, "SA%02x ", bus->dest_addr);
+	s += sprintf(s, "SA%02x ", bus->dest_addr >> 1);
 
 	switch (bus->stop_ind) {
 	case SMB_NO_STATUS_IND:
@@ -464,15 +445,9 @@ static void pdebug(struct npcm_i2c *bus, char str[20])
 	case SMB_WAKE_UP_IND:
 		s += sprintf(s, "WAKE_UP_IND        ");
 		break;
-	case SMB_MASTER_PEC_ERR_IND:
-		s += sprintf(s, "MASTER_PEC_ERR_IND ");
-		break;
 	case SMB_BLOCK_BYTES_ERR_IND:
 		s += sprintf(s, "BLK_BYTES_ERR_IND  ");
 		break;
-	case SMB_SLAVE_PEC_ERR_IND:
-		s += sprintf(s, "SLAVE_PEC_ERR_IND  ");
-		break;
 	case SMB_SLAVE_RCV_MISSING_DATA_IND:
 		s += sprintf(s, "SLAVE_RCV_MISSING  ");
 		break;
@@ -512,10 +487,11 @@ static void pdebug(struct npcm_i2c *bus, char str[20])
 
 	//npcm_smb_select_bank(bus, SMB_BANK_1);
 
-	printk("%s %s wr%d,%d rd%d,%d int%d ev0x%02x (prv=0x%02x) blk%d ST=%02x CST=%02x CTL1=%02x CTL3=%02x FIF_CTS=%02x TXF_CTL=%02x T_OUT=%02x CST2=%02x CST3=%02x TXF_STS=%02x RXF_STS=%02x RXF_CTL=%02x ",
-	       str2, str, wr_size, wr_ind, rd_size, rd_ind, bus->int_cnt,
-	       bus->event_log, bus->event_log_prev, (int)bus->read_block_use,
-	       ioread8(bus->reg + NPCM_SMBST), ioread8(bus->reg + NPCM_SMBCST),
+	pr_err("%s %s %d:% 4d, wr%d,%d rd%d,%d int%d ev0x%04x (prv=0x%04x) err% 4d ST=%02x CST=%02x CTL1=%02x CTL3=%02x FIF_CTS=%02x TXF_CTL=%02x T_OUT=%02x CST2=%02x CST3=%02x TXF_STS=%02x RXF_STS=%02x RXF_CTL=%02x xmit=%d\n",
+	       str2, str, smp_processor_id(), line, wr_size, wr_ind, rd_size,
+	       rd_ind, bus->int_cnt, bus->event_log, bus->event_log_prev,
+	       bus->cmd_err, ioread8(bus->reg + NPCM_SMBST),
+	       ioread8(bus->reg + NPCM_SMBCST),
 	       ioread8(bus->reg + NPCM_SMBCTL1),
 	       ioread8(bus->reg + NPCM_SMBCTL3),
 	       ioread8(bus->reg + NPCM_SMBFIF_CTS),
@@ -525,43 +501,17 @@ static void pdebug(struct npcm_i2c *bus, char str[20])
 	       ioread8(bus->reg + NPCM_SMBCST3),
 	       ioread8(bus->reg + NPCM_SMBTXF_STS),
 	       ioread8(bus->reg + NPCM_SMBRXF_STS),
-	       ioread8(bus->reg + NPCM_SMBRXF_CTL));
+	       ioread8(bus->reg + NPCM_SMBRXF_CTL), bus->xmits);
 
 	//npcm_smb_select_bank(bus, SMB_BANK_0);
-	//printk("CTL4=%02x CTL5=%02x FIF_CTL=%02x\n",
-	//	ioread8(bus->reg + NPCM_SMBCTL4 ),
-	//	ioread8(bus->reg + NPCM_SMBCTL5 ),
-	//	ioread8(bus->reg + NPCM_SMBFIF_CTL ));
+	//pr_err("CTL4=%02x CTL5=%02x FIF_CTL=%02x\n",
+	//	ioread8(bus->reg + NPCM_SMBCTL4),
+	//	ioread8(bus->reg + NPCM_SMBCTL5),
+	//	ioread8(bus->reg + NPCM_SMBFIF_CTL));
 	//npcm_smb_select_bank(bus, SMB_BANK_1);
-
-	if (str[0] != '#') {
-		if (bus->num == 0)
-			pdebug(buss[1], "#1_");
-		if (bus->num == 1)
-			pdebug(buss[0], "#0_");
-		if (bus->num == 6)
-			pdebug(buss[7], "#7_");
-		if (bus->num == 7)
-			pdebug(buss[6], "#6_");
-		if (bus->num == 8)
-			pdebug(buss[9], "#9_");
-		if (bus->num == 9)
-			pdebug(buss[8], "#8_");
-	}
-
-	return;
-}
-
-static void pdebug_lvl2(struct npcm_i2c *bus, char str[20])
-{
-	// remove for in-depth debug:
-#ifndef _I2C_DEBUG_
-	return;
-#endif
-	pdebug(bus, str);
 }
 
-DECLARE_CRC8_TABLE(npcm7xx_crc8);
+#define pdebug_lvl2(bus, str) pdebug(bus, __LINE__, str)
 
 static void npcm_smb_init_params(struct npcm_i2c *bus)
 {
@@ -570,65 +520,26 @@ static void npcm_smb_init_params(struct npcm_i2c *bus)
 	bus->wr_size = 0;
 	bus->rd_ind = 0;
 	bus->wr_ind = 0;
-	bus->slv_rd_size = 0;
-	bus->slv_wr_size = 0;
-	bus->slv_rd_ind = 0;
-	bus->slv_wr_ind = 0;
-	//bus->operation = SMB_NO_OPER;
-	bus->retry_count = 1; // SMB_RETRY_MAX_COUNT;
 	bus->int_cnt = 0;
 	bus->event_log_prev = bus->event_log;
 	bus->event_log = 0;
 	bus->read_block_use = false;
 	bus->int_time_stamp = 0;
-	bus->cmd_err = -EBUSY;
 	bus->PEC_use = false;
 	bus->PEC_mask = 0;
 	if (bus->slave)
 		bus->master_or_slave = SMB_SLAVE;
 	bus->threshold_fifo = SMBUS_FIFO_SIZE;
-
-	return;
-}
-
-static u8 npcm_smb_calc_crc8(u8 crc_data, u8 data)
-{
-	crc_data = crc8(npcm7xx_crc8, &data, 1, crc_data);
-	return crc_data;
-}
-
-static void npcm_smb_calc_PEC(struct npcm_i2c *bus, u8 data)
-{
-	if (bus->PEC_use)
-		bus->crc_data = npcm_smb_calc_crc8(bus->crc_data, data);
 }
 
 static inline void npcm_smb_wr_byte(struct npcm_i2c *bus, u8 data)
 {
 	iowrite8(data, bus->reg + NPCM_SMBSDA);
-	npcm_smb_calc_PEC(bus, data);
 }
 
 static inline void npcm_smb_rd_byte(struct npcm_i2c *bus, u8 *data)
 {
 	*data = ioread8(bus->reg + NPCM_SMBSDA);
-	npcm_smb_calc_PEC(bus, *data);
-}
-
-static inline u8 npcm_smb_get_PEC(struct npcm_i2c *bus)
-{
-	if (bus->PEC_use)
-		return bus->crc_data;
-	else
-		return 0;
-}
-
-static inline void npcm_smb_write_PEC(struct npcm_i2c *bus)
-{
-	if (bus->PEC_use) {
-		// get PAC value and write to the bus:
-		npcm_smb_wr_byte(bus, npcm_smb_get_PEC(bus));
-	}
 }
 
 static int npcm_smb_get_SCL(struct i2c_adapter *_adap)
@@ -636,7 +547,6 @@ static int npcm_smb_get_SCL(struct i2c_adapter *_adap)
 	unsigned int ret = 0;
 	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
 
-	// Get SCL level
 	ret = FIELD_GET(SMBCTL3_SCL_LVL, ioread8(bus->reg + NPCM_SMBCTL3));
 
 	return ret;
@@ -647,7 +557,6 @@ static int npcm_smb_get_SDA(struct i2c_adapter *_adap)
 	unsigned int ret = 0;
 	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
 
-	// Get SDA level
 	ret = FIELD_GET(SMBCTL3_SDA_LVL, ioread8(bus->reg + NPCM_SMBCTL3));
 
 	return ret;
@@ -665,7 +574,7 @@ static inline u16 npcm_smb_get_index(struct npcm_i2c *bus)
 	return index;
 }
 
-// quick protocol:
+// quick protocol (just address):
 static inline bool npcm_smb_is_quick(struct npcm_i2c *bus)
 {
 	if (bus->wr_size == 0 && bus->rd_size == 0)
@@ -680,18 +589,16 @@ static void npcm_smb_disable(struct npcm_i2c *bus)
 	// select bank 0 for SMB addresses
 	npcm_smb_select_bank(bus, SMB_BANK_0);
 
-	// Slave Addresses Removal
+	// Slave addresses removal
 	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++)
 		iowrite8(0, bus->reg + NPCM_SMBADDR[i]);
 
-	// select bank 0 for SMB addresses
 	npcm_smb_select_bank(bus, SMB_BANK_1);
 
 	// Disable module.
 	iowrite8(ioread8(bus->reg + NPCM_SMBCTL2) & ~SMBCTL2_ENABLE,
 		 bus->reg + NPCM_SMBCTL2);
 
-	// Set module disable
 	bus->state = SMB_DISABLE;
 }
 
@@ -701,16 +608,28 @@ static void npcm_smb_enable(struct npcm_i2c *bus)
 		 bus->reg + NPCM_SMBCTL2);
 }
 
-static bool npcm_smb_wait_for_bus_free(struct npcm_i2c *bus)
+static bool npcm_smb_wait_for_bus_free(struct npcm_i2c *bus, bool may_sleep)
 {
-	unsigned long timeout1 = jiffies + bus->adap.timeout;
-	while ((ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BB) == 1) {
-		if (time_after(jiffies, timeout1)) {
-			pdebug(bus, "ETIMEDOUT");
-			bus->cmd_err = -ETIMEDOUT;
+	int cnt = 0;
+	int max_count = 2; /* wait for 2 ms */
+
+	if (may_sleep)
+		might_sleep();
+	else
+		max_count = max_count * 100; /* since each delay is 10 us */
+
+	while (ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BUSY) {
+		if (cnt < max_count) {
+			if (!may_sleep)
+				udelay(10); /* delay 10 us */
+			else
+				msleep_interruptible(1);
+			cnt++;
+
+		} else {
+			bus->cmd_err = -EAGAIN;
 			return false;
 		}
-		cpu_relax();
 	}
 	return true;
 }
@@ -718,6 +637,10 @@ static bool npcm_smb_wait_for_bus_free(struct npcm_i2c *bus)
 // enable\disable end of busy (EOB) interrupt
 static inline void npcm_smb_eob_int(struct npcm_i2c *bus, bool enable)
 {
+	// Clear EO_BUSY pending bit:
+	iowrite8(ioread8(bus->reg + NPCM_SMBCST3) | NPCM_SMBCST3_EO_BUSY,
+		 bus->reg + NPCM_SMBCST3);
+
 	if (enable) {
 		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) |
 			  NPCM_SMBCTL1_EOBINTE) &
@@ -728,11 +651,6 @@ static inline void npcm_smb_eob_int(struct npcm_i2c *bus, bool enable)
 				 ~NPCM_SMBCTL1_EOBINTE &
 				 ~NPCM_SMBCTL1_RWS_FIELDS,
 			 bus->reg + NPCM_SMBCTL1);
-
-		// Clear EO_BUSY pending bit:
-		iowrite8(ioread8(bus->reg + NPCM_SMBCST3) |
-				 NPCM_SMBCST3_EO_BUSY,
-			 bus->reg + NPCM_SMBCST3);
 	}
 }
 
@@ -745,8 +663,7 @@ static inline bool npcm_smb_tx_fifo_empty(struct npcm_i2c *bus)
 		return false;
 
 	// check if TX FIFO empty:
-	return (bool)FIELD_GET(NPCM_SMBTXF_STS_TX_THST,
-			       ioread8(bus->reg + NPCM_SMBTXF_STS));
+	return (bool)FIELD_GET(NPCM_SMBTXF_STS_TX_THST, tx_fifo_sts);
 }
 
 static inline bool npcm_smb_rx_fifo_full(struct npcm_i2c *bus)
@@ -758,8 +675,7 @@ static inline bool npcm_smb_rx_fifo_full(struct npcm_i2c *bus)
 		return false;
 
 	// check if rx fifo full status is set:
-	return (bool)FIELD_GET(NPCM_SMBRXF_STS_RX_THST,
-			       ioread8(bus->reg + NPCM_SMBRXF_STS));
+	return (bool)FIELD_GET(NPCM_SMBRXF_STS_RX_THST, rx_fifo_sts);
 }
 
 static inline void npcm_smb_clear_fifo_int(struct npcm_i2c *bus)
@@ -811,7 +727,9 @@ static inline void npcm_smb_master_stop(struct npcm_i2c *bus)
 {
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_STOP);
 
+#ifdef _I2C_DEBUG_
 	pdebug_lvl2(bus, "stop  ");
+#endif /* I2C_DEBUG */
 
 	// override HW issue: SMBus may fail to supply stop condition in Master
 	// Write operation.
@@ -862,7 +780,10 @@ static void npcm_smb_reset(struct npcm_i2c *bus)
 	// Save NPCM_SMBCTL1 relevant bits. It is being cleared when the
 	// module is disabled
 	u8 smbctl1;
+
+#ifdef _I2C_DEBUG_
 	pdebug_lvl2(bus, "reset bus");
+#endif /* I2C_DEBUG */
 
 	smbctl1 = ioread8(bus->reg + NPCM_SMBCTL1);
 
@@ -887,7 +808,6 @@ static void npcm_smb_reset(struct npcm_i2c *bus)
 	// Clear all fifo bits:
 	iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO, bus->reg + NPCM_SMBFIF_CTS);
 
-	// Reset driver status
 	bus->state = SMB_IDLE;
 }
 
@@ -905,73 +825,82 @@ static void npcm_smb_callback(struct npcm_i2c *bus,
 
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_CB);
 
+#ifdef _I2C_DEBUG_
+	pdebug_lvl2(bus, "CB");
+#endif /* I2C_DEBUG */
+
+	if (!msgs) {
+#ifdef _I2C_DEBUG_
+		pdebug_lvl2(bus, "msgs");
+#endif /* I2C_DEBUG */
+		return;
+	}
+
 	if (completion_done(&bus->cmd_complete) == true) {
-		pdebug(bus, "CB com err");
+#ifdef _I2C_DEBUG_
+		pdebug_lvl2(bus, "complete");
+#endif /* I2C_DEBUG */
+		return;
 	}
 
 	switch (op_status) {
 	case SMB_MASTER_DONE_IND:
-		// Master transaction finished and all transmit bytes were sent
-		// info: number of bytes actually received after the Master
-		//	receive operation (if Master didn't issue receive it
-		//	should be 0)
-		// Notify that not all data was received on Master or Slave
-		// info:
-		//	on receive: number of actual bytes received
-		//	when PEC is used even if 'info' is the expected number
-		//	of bytes, it means that PEC error occurred.
-		{
-			if (bus->msgs != NULL) {
-				if (msgs[0].flags & I2C_M_RD)
-					msgs[0].len = info;
-				else if (msgs_num == 2 &&
-					 msgs[1].flags & I2C_M_RD)
-					msgs[1].len = info;
-			}
-			bus->cmd_err = 0;
-			NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_DONE);
-
-			if ((ioread8(bus->reg + NPCM_SMBCST) &
-			     NPCM_SMBCST_BB) != 0)
-				pdebug_lvl2(bus, "WARNING busy done");
-			if (completion_done(&bus->cmd_complete) == false)
-				complete(&bus->cmd_complete);
+		bus->cmd_err = bus->msgs_num;
+		// fall through:
+	case SMB_BLOCK_BYTES_ERR_IND:
+		// Master transaction finished and all transmit bytes
+		// were sent
+		if (bus->msgs) {
+			if (msgs[0].flags & I2C_M_RD)
+				msgs[0].len = info;
+			else if (msgs_num == 2 && msgs[1].flags & I2C_M_RD)
+				msgs[1].len = info;
 		}
+
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_DONE);
+
+		if (completion_done(&bus->cmd_complete) == false)
+			complete(&bus->cmd_complete);
 		break;
 
 	case SMB_NACK_IND:
-		// MASTER transmit got a NAK before transmitting all bytes
+		// MASTER transmit got a NACK before tx all bytes
 		// info: number of transmitted bytes
 		bus->cmd_err = -ENXIO;
-		pdebug_lvl2(bus, "CB-NACK ");
-		if (bus->master_or_slave == SMB_MASTER) {
+		if (bus->master_or_slave == SMB_MASTER)
 			complete(&bus->cmd_complete);
-		}
 
 		break;
 	case SMB_BUS_ERR_IND:
 		// Bus error
-		// info: has no meaning
-		bus->cmd_err = -EIO;
+		bus->cmd_err = -EAGAIN;
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "CB BER  ");
-		if (bus->master_or_slave == SMB_MASTER) {
+#endif /* I2C_DEBUG */
+		if (bus->master_or_slave == SMB_MASTER)
 			complete(&bus->cmd_complete);
-		}
 
 		break;
 	case SMB_WAKE_UP_IND:
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "wake_up");
+#endif /* I2C_DEBUG */
 		// SMBus wake up
-		// info: has no meaning
 		break;
 	default:
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "CB default");
+#endif /* I2C_DEBUG */
 		break;
 	}
 
 	bus->operation = SMB_NO_OPER;
 	if (bus->slave)
 		bus->master_or_slave = SMB_SLAVE;
+
+#ifdef _I2C_DEBUG_
+	pdebug_lvl2(bus, "CB_end");
+#endif /* I2C_DEBUG */
 }
 
 static u32 npcm_smb_get_fifo_fullness(struct npcm_i2c *bus)
@@ -988,7 +917,9 @@ static u32 npcm_smb_get_fifo_fullness(struct npcm_i2c *bus)
 static void npcm_smb_write_to_fifo_master(struct npcm_i2c *bus,
 					  u16 max_bytes_to_send)
 {
+#ifdef _I2C_DEBUG_
 	pdebug_lvl2(bus, "wr_fifo_master");
+#endif /* I2C_DEBUG */
 	// Fill the FIFO, while the FIFO is not full and there are more bytes to
 	// write
 	if (max_bytes_to_send == 0)
@@ -996,19 +927,10 @@ static void npcm_smb_write_to_fifo_master(struct npcm_i2c *bus,
 	while ((max_bytes_to_send--) &&
 	       (SMBUS_FIFO_SIZE - npcm_smb_get_fifo_fullness(bus))) {
 		// write the data
-		if (bus->wr_ind < bus->wr_size) {
-			if (bus->PEC_use && (bus->wr_ind + 1 == bus->wr_size)) {
-				// Master send PEC in write protocol, Slave send
-				// PEC in read protocol.
-				npcm_smb_write_PEC(bus);
-				bus->wr_ind++;
-			} else {
-				npcm_smb_wr_byte(bus,
-						 bus->wr_buf[bus->wr_ind++]);
-			}
-		} else {
+		if (bus->wr_ind < bus->wr_size)
+			npcm_smb_wr_byte(bus, bus->wr_buf[bus->wr_ind++]);
+		else
 			npcm_smb_wr_byte(bus, 0xFF);
-		}
 	}
 }
 
@@ -1016,7 +938,9 @@ static void npcm_smb_write_to_fifo_master(struct npcm_i2c *bus,
 static void npcm_smb_write_to_fifo_slave(struct npcm_i2c *bus,
 					 u16 max_bytes_to_send)
 {
+#ifdef _I2C_DEBUG_
 	pdebug_lvl2(bus, "wr_fifo");
+#endif /* I2C_DEBUG */
 	// Fill the FIFO, while the FIFO is not full and there are more bytes to
 	// write
 	npcm_smb_clear_fifo_int(bus);
@@ -1028,18 +952,22 @@ static void npcm_smb_write_to_fifo_slave(struct npcm_i2c *bus,
 
 	while ((max_bytes_to_send--) &&
 	       (SMBUS_FIFO_SIZE - npcm_smb_get_fifo_fullness(bus))) {
-		// write the data
 		if (bus->slv_wr_size > 0) {
 			npcm_smb_wr_byte(bus, bus->slv_wr_buf[bus->slv_wr_ind %
 							      SMBUS_FIFO_SIZE]);
+#ifdef _I2C_DEBUG_
+			printk("bus%d: wr fifo 0x%x\n", bus->num,
+			       bus->slv_wr_buf[bus->slv_wr_ind %
+					       SMBUS_FIFO_SIZE]);
+#endif
 			bus->slv_wr_ind =
 				(bus->slv_wr_ind + 1) % SMBUS_FIFO_SIZE;
-			bus->slv_wr_size--; // more bytes in fifo, less in cyclic buffer.
-		} else
+			bus->slv_wr_size--; // size indicates the # of bytes in
+				// the SW FIFO, not HW.
+		} else {
 			break;
+		}
 	}
-
-	pdebug_lvl2(bus, "wr_fifo_done");
 }
 #endif
 
@@ -1047,7 +975,8 @@ static void npcm_smb_write_to_fifo_slave(struct npcm_i2c *bus,
 // configured. same for	nwrite
 static void npcm_smb_set_fifo(struct npcm_i2c *bus, int nread, int nwrite)
 {
-	u16 rxf_ctl = 0;
+	u8 rxf_ctl = 0;
+
 	if (!bus->fifo_use)
 		return;
 	npcm_smb_select_bank(bus, SMB_BANK_1);
@@ -1056,17 +985,16 @@ static void npcm_smb_set_fifo(struct npcm_i2c *bus, int nread, int nwrite)
 
 	// configure RX FIFO
 	if (nread > 0) {
-		rxf_ctl = min((u16)nread, (u16)SMBUS_FIFO_SIZE);
-
-		// set LAST bit. if LAST is set enxt FIFO packet is nacked at the end.
+		rxf_ctl = min_t(u16, (u16)nread, (u16)SMBUS_FIFO_SIZE);
 
+		// set LAST bit. if LAST is set enxt FIFO packet is nacked
 		// regular read of less then buffer size:
 		if (nread <= SMBUS_FIFO_SIZE)
 			rxf_ctl |= NPCM_SMBRXF_CTL_LAST_PEC;
 		// if we are about to read the first byte in blk rd mode,
-		// don't NACK it. BTW , if slave return zero size HW can't NACK
-		// it immidiattly, it will read enxtra byte and then NACK.
-		if ((bus->rd_ind == 0) && bus->read_block_use) {
+		// don't NACK it. BTW, if slave return zero size HW can't NACK
+		// it immidiattly, it will read extra byte and then NACK.
+		if (bus->rd_ind == 0 && bus->read_block_use) {
 			// set fifo to read one byte, no last:
 			rxf_ctl = 1;
 		}
@@ -1079,44 +1007,41 @@ static void npcm_smb_set_fifo(struct npcm_i2c *bus, int nread, int nwrite)
 	if (nwrite > 0) {
 		if (nwrite > SMBUS_FIFO_SIZE)
 			// data to send is more then FIFO size.
-			// Configure the FIFO int to be mid of FIFO.
+			// Configure the FIFO int to be after of FIFO is cleared
 			iowrite8(SMBUS_FIFO_SIZE, bus->reg + NPCM_SMBTXF_CTL);
 		else
 			iowrite8(nwrite, bus->reg + NPCM_SMBTXF_CTL);
 
 		npcm_smb_clear_tx_fifo(bus);
 	}
+
+#ifdef _I2C_DEBUG_
+	pdebug_lvl2(bus, "set_fifo");
+#endif /* I2C_DEBUG */
 }
 
 static void npcm_smb_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
 {
 	u8 data;
-#ifdef _I2C_DEBUG_
-	if (bus->num == 1)
-		printk("read fifo %d\n", bytes_in_fifo);
-#endif
+
 	while (bytes_in_fifo--) {
 		npcm_smb_rd_byte(bus, &data);
 
-		if (npcm_smb_is_master(bus)) {
-			if (bus->rd_ind < bus->rd_size) {
+		if (bus->master_or_slave == SMB_MASTER) {
+			if (bus->rd_ind < bus->rd_size)
 				bus->rd_buf[bus->rd_ind++] = data;
-				if (bus->rd_ind == 1 && bus->read_block_use) {
-					// First byte indicates length in block protocol
-					bus->rd_size = data;
-					pdebug_lvl2(bus, "blk rcv");
-				}
-			}
 		} else { // SMB_SLAVE:
-//printk("s fifo read\r\n");
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
-			bus->slv_rd_buf[bus->slv_rd_ind % SMBUS_FIFO_SIZE] =
-				data;
-			bus->slv_rd_ind++;
-			if (bus->slv_rd_ind == 1 && bus->read_block_use)
-				// First byte indicates length in block protocol
-				bus->rd_size = data;
-
+			if (bus->slave) {
+				bus->slv_rd_buf[bus->slv_rd_ind %
+						SMBUS_FIFO_SIZE] = data;
+				bus->slv_rd_ind++;
+				if (bus->slv_rd_ind == 1 && bus->read_block_use)
+					// 1st byte is length in block protocol
+					bus->slv_rd_size =
+						data + (u8)bus->PEC_use +
+						(u8)bus->read_block_use;
+			}
 #endif
 		}
 	}
@@ -1125,53 +1050,43 @@ static void npcm_smb_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
 static int npcm_smb_master_abort(struct npcm_i2c *bus)
 {
 	int ret = 0;
-	int len;
 
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_ABORT);
 
-	pdebug_lvl2(bus, " abort data 1 ");
+#ifdef _I2C_DEBUG_
+	pdebug_lvl2(bus, "abort");
+#endif /* I2C_DEBUG */
 
 	// Only current master is allowed to issue Stop Condition
 	if (npcm_smb_is_master(bus)) {
-		pdebug_lvl2(bus, " abort data 2 ");
-		// stoping in the middle, not waing for interrupts anymore
+		// stopping in the middle, not waitng for interrupts anymore
 		npcm_smb_eob_int(bus, false);
 
 		// Generate a STOP condition (after next wr\rd from fifo:
 		npcm_smb_master_stop(bus);
 
-		if ((NPCM_SMBST_XMIT & ioread8(bus->reg + NPCM_SMBST)) == 0) {
-			// gracefully abort read transaction
-			len = npcm_smb_get_fifo_fullness(bus);
-
-			if (len > 0)
-				npcm_smb_read_from_fifo(bus, len);
-		}
-
-		npcm_smb_wait_for_bus_free(bus);
-
 		// Clear NEGACK, STASTR and BER bits
 		iowrite8(NPCM_SMBST_BER | NPCM_SMBST_NEGACK | NPCM_SMBST_STASTR,
 			 bus->reg + NPCM_SMBST);
 
-		pdebug_lvl2(bus, " abort data 3 ");
+		npcm_smb_wait_for_bus_free(bus, false);
+
+		npcm_smb_reset(bus);
 	}
 
 	return ret;
 }
 
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
-
 static irqreturn_t npcm_i2c_bus_irq(int irq, void *dev_id);
 
 static int npcm_smb_slave_enable_l(struct npcm_i2c *bus,
 				   enum smb_addr addr_type, u8 addr,
 				   bool enable)
 {
-	u8 SmbAddrX_Addr = FIELD_PREP(NPCM_SMBADDR_ADDR, addr) |
-			   FIELD_PREP(NPCM_SMBADDR_SAEN, enable);
+	u8 slave_addr_reg = FIELD_PREP(NPCM_SMBADDR_A, addr) |
+			    FIELD_PREP(NPCM_SMBADDR_SAEN, enable);
 
-	pdebug_lvl2(bus, " slave enable ");
 	if (addr_type == SMB_GC_ADDR) {
 		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) &
 			  ~NPCM_SMBCTL1_GCMEN) |
@@ -1188,72 +1103,53 @@ static int npcm_smb_slave_enable_l(struct npcm_i2c *bus,
 	if (addr_type >= SMB_ARP_ADDR)
 		return -EFAULT;
 
-	// Disable ints and select bank 0 for address 3 to ...
-	if (addr_type > SMB_SLAVE_ADDR1)
+	// select bank 0 for address 3 to 10
+	if (addr_type > SMB_SLAVE_ADDR2)
 		npcm_smb_select_bank(bus, SMB_BANK_0);
 
 	// Set and enable the address
-	iowrite8(SmbAddrX_Addr, bus->reg + NPCM_SMBADDR[(int)addr_type]);
+	iowrite8(slave_addr_reg, bus->reg + NPCM_SMBADDR[(int)addr_type]);
 
-	// return to bank 1 and enable ints (if needed)
-	if (addr_type > SMB_SLAVE_ADDR1)
+	if (addr_type > SMB_SLAVE_ADDR2)
 		npcm_smb_select_bank(bus, SMB_BANK_1);
-
-	pdebug_lvl2(bus, " slave enable done ");
-
 	return 0;
 }
 
-static u8 npcm_smb_get_slave_addr_l(struct npcm_i2c *bus,
-				    enum smb_addr addr_type)
+static u8 npcm_smb_get_slave_addr(struct npcm_i2c *bus, enum smb_addr addr_type)
 {
-	u8 slaveAddress;
-
-	// disable ints and select bank 0 for address 3 to ...
-	npcm_smb_select_bank(bus, SMB_BANK_0);
+	u8 slave_add;
 
-	// printk("I2C%d get addr %d", bus->num, (int)addr_type);
+	// select bank 0 for address 3 to 10
+	if (addr_type > SMB_SLAVE_ADDR2)
+		npcm_smb_select_bank(bus, SMB_BANK_0);
 
-	slaveAddress = ioread8(bus->reg + NPCM_SMBADDR[(int)addr_type]);
+	slave_add = ioread8(bus->reg + NPCM_SMBADDR[(int)addr_type]);
 
-	// return to bank 1 and enable ints (if needed)
-	npcm_smb_select_bank(bus, SMB_BANK_1);
+	if (addr_type > SMB_SLAVE_ADDR2)
+		npcm_smb_select_bank(bus, SMB_BANK_1);
 
-	return slaveAddress;
+	return slave_add;
 }
 
 #if defined(TODO_MULTI_SA) // poleg support up to 10 SA.
-static bool npcm_smb_is_slave_addr_exist(struct npcm_i2c *bus, u8 addr)
-{
-	int i;
-
-	addr |= 0x80; //Set the enable bit
 
-	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++)
-		if (addr == npcm_smb_get_slave_addr_l(bus, (enum smb_addr)i))
-			return true;
-
-	return false;
-}
-
-static int npcm_smb_add_slave_addr(struct npcm_i2c *bus, u8 slaveAddrToAssign,
+static int npcm_smb_add_slave_addr(struct npcm_i2c *bus, u8 slave_addr,
 				   bool use_PEC)
 {
 	u16 i;
 	int ret = -EFAULT;
-	// printk("slaveAddrToAssign = %02X\n", slaveAddrToAssign);
 
-	slaveAddrToAssign |= 0x80; //set the enable bit
+	slave_addr |= 0x80; //set the enable bit
 
 	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++) {
-		u8 currentSlaveAddr =
-			npcm_smb_get_slave_addr_l(bus, (enum smb_addr)i);
-		if (currentSlaveAddr == slaveAddrToAssign) {
+		u8 cur_slave_addr =
+			npcm_smb_get_slave_addr(bus, (enum smb_addr)i);
+		if (cur_slave_addr == slave_addr) {
 			ret = 0;
 			break;
-		} else if ((currentSlaveAddr & 0x7F) == 0) {
+		} else if ((cur_slave_addr & 0x7F) == 0) {
 			ret = npcm_smb_slave_enable_l(bus, (enum smb_addr)i,
-						      slaveAddrToAssign, true);
+						      slave_addr, true);
 			break;
 		}
 	}
@@ -1266,40 +1162,27 @@ static int npcm_smb_add_slave_addr(struct npcm_i2c *bus, u8 slaveAddrToAssign,
 	}
 	return ret;
 }
-
-static int npcm_smb_get_current_slave_addr(struct npcm_i2c *bus,
-					   u8 *currSlaveAddr)
-{
-	if (currSlaveAddr != NULL) {
-		*currSlaveAddr = bus->own_slave_addr;
-		return 0;
-	}
-
-	return -EFAULT;
-}
 #endif //TODO_MULTI_SA
 
-static int npcm_smb_remove_slave_addr(struct npcm_i2c *bus,
-				      u8 slaveAddrToRemove)
+static int npcm_smb_remove_slave_addr(struct npcm_i2c *bus, u8 slave_add)
 {
 	int i;
-	slaveAddrToRemove |= 0x80; //Set the enable bit
 
-	// disable ints and select bank 0 for address 3 to ...
+	slave_add |= 0x80; //Set the enable bit
+
 	npcm_smb_select_bank(bus, SMB_BANK_0);
 
 	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++) {
-		if (ioread8(bus->reg + NPCM_SMBADDR[i]) == slaveAddrToRemove)
+		if (ioread8(bus->reg + NPCM_SMBADDR[i]) == slave_add)
 			iowrite8(0, bus->reg + NPCM_SMBADDR[i]);
 	}
 
-	// return to bank 1 and enable ints (if needed)
 	npcm_smb_select_bank(bus, SMB_BANK_1);
 
 	return 0;
 }
 
-#if defined(TODO_MULTI_SA) // poleg support up to 10 SA.
+#if defined(TODO_MULTI_SA) // poleg supports up to 10 SA.
 static int npcm_smb_slave_global_call_enable(struct npcm_i2c *bus, bool enable)
 {
 	return npcm_smb_slave_enable_l(bus, SMB_GC_ADDR, 0, enable);
@@ -1317,7 +1200,9 @@ static int npcm_i2c_slave_get_wr_buf(struct npcm_i2c *bus)
 	int ret = bus->slv_wr_ind;
 	int i;
 
+#ifdef _I2C_DEBUG_
 	pdebug_lvl2(bus, "slv wr buf 1");
+#endif /* I2C_DEBUG */
 
 	// fill a cyclic buffer
 	for (i = 0; i < SMBUS_FIFO_SIZE; i++) {
@@ -1329,15 +1214,15 @@ static int npcm_i2c_slave_get_wr_buf(struct npcm_i2c *bus)
 		bus->slv_wr_size++;
 		i2c_slave_event(bus->slave, I2C_SLAVE_READ_PROCESSED, &value);
 	}
-
 #ifdef _I2C_DEBUG_
-	printk("\nI2C%d get wr buf [%d / %d]\n\t  %x %x %x %x   %x %x %x %x    %x %x %x %x    %x %x %x %x\n",
-	       bus->num, bus->slv_wr_ind, bus->slv_wr_size, bus->slv_wr_buf[0],
-	       bus->slv_wr_buf[1], bus->slv_wr_buf[2], bus->slv_wr_buf[3],
-	       bus->slv_wr_buf[4], bus->slv_wr_buf[5], bus->slv_wr_buf[6],
-	       bus->slv_wr_buf[7], bus->slv_wr_buf[8], bus->slv_wr_buf[9],
-	       bus->slv_wr_buf[10], bus->slv_wr_buf[11], bus->slv_wr_buf[12],
-	       bus->slv_wr_buf[13], bus->slv_wr_buf[14], bus->slv_wr_buf[15]);
+	printk("bus%d get wr  0x%x 0x%x 0x%x 0x%x  0x%x 0x%x 0x%x 0x%x  0x%x 0x%x 0x%x 0x%x  0x%x 0x%x 0x%x 0x%x\n",
+	       bus->num, bus->slv_wr_buf[0], bus->slv_wr_buf[1],
+	       bus->slv_wr_buf[2], bus->slv_wr_buf[3], bus->slv_wr_buf[4],
+	       bus->slv_wr_buf[5], bus->slv_wr_buf[6], bus->slv_wr_buf[7],
+	       bus->slv_wr_buf[8], bus->slv_wr_buf[9], bus->slv_wr_buf[10],
+	       bus->slv_wr_buf[11], bus->slv_wr_buf[12], bus->slv_wr_buf[13],
+	       bus->slv_wr_buf[14], bus->slv_wr_buf[15]);
+	printk("wr ind = %d size %d\n", bus->slv_wr_ind, bus->slv_wr_size);
 #endif
 
 	return SMBUS_FIFO_SIZE - ret;
@@ -1347,13 +1232,9 @@ static void npcm_i2c_slave_send_rd_buf(struct npcm_i2c *bus)
 {
 	int i;
 
-	for (i = 0; i < bus->slv_rd_ind; i++) {
-#ifdef _I2C_DEBUG_
-		printk("->   send 0x%x\n", bus->slv_rd_buf[i]);
-#endif
+	for (i = 0; i < bus->slv_rd_ind; i++)
 		i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_RECEIVED,
 				&bus->slv_rd_buf[i]);
-	}
 
 	// once we send bytes up, need to reset the counter of the wr buf
 	// got data from master (new offset in device), ignore wr fifo:
@@ -1363,18 +1244,19 @@ static void npcm_i2c_slave_send_rd_buf(struct npcm_i2c *bus)
 	}
 
 	bus->slv_rd_ind = 0;
-	bus->slv_rd_size = 32 * 1024;
+	bus->slv_rd_size = bus->adap.quirks->max_read_len;
 
 	npcm_smb_clear_fifo_int(bus);
 	npcm_smb_clear_rx_fifo(bus);
 }
 
-static bool npcm_smb_slave_start_receive(struct npcm_i2c *bus, u16 nread,
-					 u8 *read_data)
+static bool npcm_smb_slave_receive(struct npcm_i2c *bus, u16 nread,
+				   u8 *read_data)
 {
+#ifdef _I2C_DEBUG_
 	pdebug_lvl2(bus, "start slv rcv");
+#endif /* I2C_DEBUG */
 
-	// Update driver state
 	bus->state = SMB_OPER_STARTED;
 	bus->operation = SMB_READ_OPER;
 	bus->slv_rd_size = nread;
@@ -1389,10 +1271,12 @@ static bool npcm_smb_slave_start_receive(struct npcm_i2c *bus, u16 nread,
 	return true;
 }
 
-static bool npcm_smb_slave_start_xmit(struct npcm_i2c *bus, u16 nwrite,
-				      u8 *write_data)
+static bool npcm_smb_slave_xmit(struct npcm_i2c *bus, u16 nwrite,
+				u8 *write_data)
 {
+#ifdef _I2C_DEBUG_
 	pdebug_lvl2(bus, "slv xmt ");
+#endif /* I2C_DEBUG */
 
 	if (nwrite == 0)
 		return false;
@@ -1403,56 +1287,17 @@ static bool npcm_smb_slave_start_xmit(struct npcm_i2c *bus, u16 nwrite,
 	// get the next buffer
 	npcm_i2c_slave_get_wr_buf(bus);
 
-	if (nwrite > 0) {
-		// Fill the FIFO with data
+	if (nwrite > 0)
 		npcm_smb_write_to_fifo_slave(bus, nwrite);
-	}
 
 	return true;
 }
 
-#if 0
-static void npcm_smb_slave_abort(struct npcm_i2c *bus)
-{
-	volatile u8 temp;
-
-	pdebug_lvl2(bus, "slv abort");
-	// Disable int.
-	npcm_smb_int_enable(bus, false);
-
-	// Dummy read to clear interface.
-	temp = ioread8(bus->reg + NPCM_SMBSDA);
-
-	// Clear NMATCH and BER bits by writing 1s to them.
-	iowrite8(ioread8(bus->reg + NPCM_SMBST) | NPCM_SMBST_BER
-		 | NPCM_SMBST_NMATCH,
-		 bus->reg + NPCM_SMBST);
-
-	bus->stop_ind = SMB_BUS_ERR_IND;
-
-	// Disable SMB Module
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL2)	& ~SMBCTL2_ENABLE),
-			bus->reg + NPCM_SMBCTL2);
-
-	// Delay 100 us
-	udelay(100); // TBD must be out of int
-
-	// Enable SMB Module
-	npcm_smb_enable(bus);
-
-	// Enable int.
-	npcm_smb_int_enable(bus, true);
-
-	// Reset driver status
-	bus->state = SMB_IDLE;
-}
-#endif
-
 // currently slave IF only supports single byte operations.
 // in order to utilyze the npcm HW FIFO, the driver will ask for 16 bytes
 // at a time, pack them in buffer, and then transmit them all together
-// to the FIFO and onward to the bus .
-// NACK on read will be once reached to bus->adap->quirks->max_read_len
+// to the FIFO and onward to the bus.
+// NACK on read will be once reached to bus->adap->quirks->max_read_len.
 // sending a NACK wherever the backend requests for it is not supported.
 // the next two functions allow reading to local buffer before writing it all
 // to the HW FIFO.
@@ -1466,13 +1311,8 @@ static int npcm_i2c_slave_wr_buf_sync(struct npcm_i2c *bus)
 	if (left_in_fifo >= SMBUS_FIFO_SIZE)
 		return left_in_fifo;
 
-	if (bus->slv_wr_size >= SMBUS_FIFO_SIZE) {
-#ifdef _I2C_DEBUG_
-		printk("wr buf full, [%d - %d] left %d", bus->slv_wr_ind,
-		       bus->slv_wr_size, left_in_fifo);
-#endif
-		return left_in_fifo; // you can't fill a cup which is already full
-	}
+	if (bus->slv_wr_size >= SMBUS_FIFO_SIZE)
+		return left_in_fifo; // fifo already full
 
 	// update the wr fifo ind, back to the untransmitted bytes:
 	bus->slv_wr_ind = bus->slv_wr_ind - left_in_fifo;
@@ -1484,48 +1324,74 @@ static int npcm_i2c_slave_wr_buf_sync(struct npcm_i2c *bus)
 	return left_in_fifo;
 }
 
+static void npcm_i2c_slave_rd_wr(struct npcm_i2c *bus)
+{
+	if (FIELD_GET(NPCM_SMBST_XMIT, ioread8(bus->reg + NPCM_SMBST))) {
+		// Slave got an address match with direction bit 1 so
+		// it should transmit data
+		// Write till the master will NACK
+		bus->operation = SMB_WRITE_OPER;
+		npcm_smb_slave_xmit(bus, bus->adap.quirks->max_write_len,
+				    bus->slv_wr_buf);
+	} else {
+		// Slave got an address match with direction bit 0
+		// so it should receive data.
+		// this module does not support saying no to bytes.
+		// it will always ACK.
+		bus->operation = SMB_READ_OPER;
+		npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+		bus->stop_ind = SMB_SLAVE_RCV_IND;
+		npcm_i2c_slave_send_rd_buf(bus);
+		npcm_smb_slave_receive(bus, bus->adap.quirks->max_read_len,
+				       bus->slv_rd_buf);
+	}
+}
+
 static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 {
 	irqreturn_t ret = IRQ_NONE;
+	u8 smbst = ioread8(bus->reg + NPCM_SMBST);
+#ifdef _I2C_DEBUG_
+	pdebug_lvl2(bus, "slave_handler");
+#endif /* I2C_DEBUG */
 
-	// Slave: A negative acknowledge has occurred
-	if (FIELD_GET(NPCM_SMBST_NEGACK, ioread8(bus->reg + NPCM_SMBST))) {
+	// Slave: A NACK has occurred
+	if (FIELD_GET(NPCM_SMBST_NEGACK, smbst)) {
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NACK);
 		bus->stop_ind = SMB_NACK_IND;
-		printk("s nack\r\n");
 		npcm_i2c_slave_wr_buf_sync(bus);
-		if (bus->fifo_use) {
+		if (bus->fifo_use)
 			// clear the FIFO
 			iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
 				 bus->reg + NPCM_SMBFIF_CTS);
-		}
 
-		pdebug_lvl2(bus, "int NACK slave");
-
-		// In slave write operation, NACK is OK, otherwise it is a problem
+		// In slave write, NACK is OK, otherwise it is a problem
 		bus->stop_ind = SMB_NO_STATUS_IND;
 		bus->operation = SMB_NO_OPER;
 		bus->own_slave_addr = 0xFF;
 
-		// Slave has to wait for SMB_STOP to decide this is the end of the transaction.
+		// Slave has to wait for SMB_STOP to decide this is the end
+		// of the transaction.
 		// Therefore transaction is not yet considered as done
 		iowrite8(NPCM_SMBST_NEGACK, bus->reg + NPCM_SMBST);
 
 		ret = IRQ_HANDLED;
 	}
 
-	// Slave mode: a Bus Error has been identified
-	if (FIELD_GET(NPCM_SMBST_BER, ioread8(bus->reg + NPCM_SMBST))) {
+	// Slave mode: a Bus Error (BER) has been identified
+	if (FIELD_GET(NPCM_SMBST_BER, smbst)) {
 		// Check whether bus arbitration or Start or Stop during data
 		// xfer bus arbitration problem should not result in recovery
-		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_BER);
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_BER_SLV);
 		bus->stop_ind = SMB_BUS_ERR_IND;
+
+		// wait for bus busy before clear fifo
 		iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO, bus->reg + NPCM_SMBFIF_CTS);
-		npcm_smb_init_params(bus);
-		//printk("s ber\r\n");
+
 		bus->state = SMB_IDLE;
 
-		// in BER case, we are not sure if SMBST.MASTER is accurate:
+		// in BER case we might get 2 interrupts: one for slave one for
+		// master ( for a channel which is master\slave switching)
 		if (completion_done(&bus->cmd_complete) == false) {
 			bus->cmd_err = -EIO;
 			complete(&bus->cmd_complete);
@@ -1536,36 +1402,34 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 	}
 
 	// A Slave Stop Condition has been identified
-	if (FIELD_GET(NPCM_SMBST_SLVSTP, ioread8(bus->reg + NPCM_SMBST))) {
+	if (FIELD_GET(NPCM_SMBST_SLVSTP, smbst)) {
+		int bytes_in_fifo = npcm_smb_get_fifo_fullness(bus);
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "int slv stop");
-		//printk("s stop\r\n");
+#endif /* I2C_DEBUG */
 		bus->stop_ind = SMB_SLAVE_DONE_IND;
 
 		if (bus->operation == SMB_READ_OPER) {
-			npcm_smb_read_from_fifo(
-				bus, npcm_smb_get_fifo_fullness(bus));
+			npcm_smb_read_from_fifo(bus, bytes_in_fifo);
 
-			// if PEC is used and PEC is correct
-			if ((bus->PEC_use == true) &&
-			    (npcm_smb_get_PEC(bus) != 0)) {
-				bus->stop_ind = SMB_SLAVE_PEC_ERR_IND;
-			}
+			// Slave done transmitting or receiving
+			// if the buffer is empty nothing will be sent
 		}
 
 		// Slave done transmitting or receiving
-		npcm_i2c_slave_send_rd_buf(
-			bus); // if the buffer is empty nothing will be sent
+		// if the buffer is empty nothing will be sent
+		npcm_i2c_slave_send_rd_buf(bus);
 
 		bus->stop_ind = SMB_NO_STATUS_IND;
 
-		// Note , just because we got here, it doesn't mean we through away the wr buffer.
+		// Note , just because we got here, it doesn't mean we through
+		// away the wr buffer.
 		// we keep it until the next received offset.
 		bus->operation = SMB_NO_OPER;
 		bus->int_cnt = 0;
 		bus->event_log_prev = bus->event_log;
 		bus->event_log = 0;
 		bus->own_slave_addr = 0xFF;
-		pdebug_lvl2(bus, "SLV_DONE");
 
 		i2c_slave_event(bus->slave, I2C_SLAVE_STOP, 0);
 
@@ -1576,58 +1440,51 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 			npcm_smb_clear_rx_fifo(bus);
 			npcm_smb_clear_tx_fifo(bus);
 
-			// clear the FIFO
 			iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
 				 bus->reg + NPCM_SMBFIF_CTS);
 		}
 
-		pdebug_lvl2(bus, "int slv stop done2");
-
 		bus->state = SMB_IDLE;
-
 		ret = IRQ_HANDLED;
 	}
 
-	// When a start condition occurred, the Rx-FIFO was not empty
+	// restart condition occurred and Rx-FIFO was not empty
 	if (bus->fifo_use && FIELD_GET(NPCM_SMBFIF_CTS_SLVRSTR,
 				       ioread8(bus->reg + NPCM_SMBFIF_CTS))) {
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "int slave restart");
-		//printk("s resta\r\n");
+#endif /* I2C_DEBUG */
 		bus->stop_ind = SMB_SLAVE_RESTART_IND;
 
-		if (bus->operation == SMB_READ_OPER) {
+		bus->master_or_slave = SMB_SLAVE;
+
+		if (bus->operation == SMB_READ_OPER)
 			npcm_smb_read_from_fifo(
 				bus, npcm_smb_get_fifo_fullness(bus));
-		}
 
 		bus->operation = SMB_WRITE_OPER;
 
 		iowrite8(0, bus->reg + NPCM_SMBRXF_CTL);
 
-		pdebug_lvl2(bus, "CB: slv restart");
-		npcm_i2c_slave_send_rd_buf(
-			bus); // send up whatever is on the buffer.
-
 		iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO | NPCM_SMBFIF_CTS_SLVRSTR |
 				 NPCM_SMBFIF_CTS_RXF_TXE,
 			 bus->reg + NPCM_SMBFIF_CTS);
 
-		// Slave got an address match with direction bit set so it
-		//	should transmit data
-		// Write till the master will NACK
-		npcm_smb_slave_start_xmit(bus, bus->adap.quirks->max_write_len,
-					  bus->slv_wr_buf);
+		npcm_i2c_slave_rd_wr(bus);
 
 		ret = IRQ_HANDLED;
 	}
 
 	// A Slave Address Match has been identified
-	if (FIELD_GET(NPCM_SMBST_NMATCH, ioread8(bus->reg + NPCM_SMBST))) {
+	if (FIELD_GET(NPCM_SMBST_NMATCH, smbst)) {
 		u8 info = 0;
 
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NMATCH_SLV);
+
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "int slave match");
+#endif /* I2C_DEBUG */
 
-		//printk("s match\r\n");
 		// Address match automatically implies slave mode
 		bus->master_or_slave = SMB_SLAVE;
 
@@ -1637,145 +1494,86 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 		iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
 		iowrite8(SMBUS_FIFO_SIZE, bus->reg + NPCM_SMBRXF_CTL);
 
-		if (FIELD_GET(NPCM_SMBST_XMIT,
-			      ioread8(bus->reg + NPCM_SMBST))) {
+		if (FIELD_GET(NPCM_SMBST_XMIT, smbst)) {
 			bus->operation = SMB_WRITE_OPER;
-			bus->stop_ind = SMB_SLAVE_XMIT_IND;
-			iowrite8(NPCM_SMBST_XMIT, bus->reg + NPCM_SMBST);
 		} else {
 			i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_REQUESTED,
 					&info);
 			bus->operation = SMB_READ_OPER;
-			bus->stop_ind = SMB_SLAVE_RCV_IND;
 		}
 
 		if (bus->own_slave_addr == 0xFF) { // unknown address
 			// Check which type of address match
 			if (FIELD_GET(NPCM_SMBCST_MATCH,
 				      ioread8(bus->reg + NPCM_SMBCST))) {
-				u16 address_match =
-					((ioread8(bus->reg + NPCM_SMBCST3) &
-					  0x7)
-					 << 7) |
-					(ioread8(bus->reg + NPCM_SMBCST2) &
-					 0x7F);
-				info = 0;
-
-				while (address_match) {
-					if (address_match & 1)
-						break;
-					info++;
-					address_match = address_match >> 1;
-				}
-				bus->own_slave_addr = FIELD_GET(
-					NPCM_SMBADDR_ADDR,
-					npcm_smb_get_slave_addr_l(
-						bus, (enum smb_addr)info));
-				if (bus->PEC_mask & BIT(info)) {
+				u16 addr;
+				enum smb_addr eaddr;
+
+				addr = ((ioread8(bus->reg + NPCM_SMBCST3) & 0x7)
+					<< 7) |
+				       (ioread8(bus->reg + NPCM_SMBCST2) &
+					0x7F);
+
+				info = ffs(addr);
+				eaddr = (enum smb_addr)info;
+
+				addr = FIELD_GET(
+					NPCM_SMBADDR_A,
+					npcm_smb_get_slave_addr(bus, eaddr));
+				bus->own_slave_addr = addr;
+
+				if (bus->PEC_mask & BIT(info))
 					bus->PEC_use = true;
-					bus->crc_data = 0;
-					if (bus->stop_ind == SMB_SLAVE_XMIT_IND)
-						npcm_smb_calc_PEC(
-							bus,
-							(bus->own_slave_addr &
-							 0x7F) << 1 |
-								1);
-					else
-						npcm_smb_calc_PEC(
-							bus,
-							(bus->own_slave_addr &
-							 0x7F) << 1);
-				} else
+				else
 					bus->PEC_use = false;
 			} else {
 				if (FIELD_GET(NPCM_SMBCST_GCMATCH,
-					      ioread8(bus->reg + NPCM_SMBCST))) {
+					      ioread8(bus->reg + NPCM_SMBCST)))
 					bus->own_slave_addr = 0;
-				} else {
-					if (FIELD_GET(NPCM_SMBCST_ARPMATCH,
-						      ioread8(bus->reg +
-							      NPCM_SMBCST))) {
-						bus->own_slave_addr = 0x61;
-					}
-				}
+				if (FIELD_GET(NPCM_SMBCST_ARPMATCH,
+					      ioread8(bus->reg + NPCM_SMBCST)))
+					bus->own_slave_addr = 0x61;
 			}
 		} else {
 			//  Slave match can happen in two options:
-			//  1. Start, SA, read	( slave read without further ado).
-			//  2. Start, SA, read , data , restart, SA, read,  ... ( slave read in fragmented mode)
-			//  3. Start, SA, write, data, restart, SA, read, .. ( regular write-read mode)
+			//  1. Start, SA, read	(slave read without further ado)
+			//  2. Start, SA, read , data , restart, SA, read,  ...
+			//     (slave read in fragmented mode)
+			//  3. Start, SA, write, data, restart, SA, read, ..
+			//     (regular write-read mode)
 			if ((bus->state == SMB_OPER_STARTED &&
 			     bus->operation == SMB_READ_OPER &&
 			     bus->stop_ind == SMB_SLAVE_XMIT_IND) ||
-			    (bus->stop_ind == SMB_SLAVE_RCV_IND)) {
-				// slave transmit after slave receive w/o Slave Stop implies repeated start
+			    bus->stop_ind == SMB_SLAVE_RCV_IND) {
+				// slave transmit after slave receive w/o Slave
+				// Stop implies repeated start
 				bus->stop_ind = SMB_SLAVE_RESTART_IND;
-				npcm_smb_calc_PEC(
-					bus,
-					(bus->own_slave_addr & 0x7F) << 1 | 1);
 			}
 		}
 
-		bus->state = SMB_SLAVE_MATCH;
-
-		if (FIELD_GET(NPCM_SMBST_XMIT,
-			      ioread8(bus->reg + NPCM_SMBST))) {
-			//printk("s xmit\r\n");
-			// Slave got an address match with direction bit set so it
-			//	should transmit data
-			// Write till the master will NACK
-			npcm_smb_slave_start_xmit(
-				bus, bus->adap.quirks->max_write_len,
-				bus->slv_wr_buf);
+		if (FIELD_GET(NPCM_SMBST_XMIT, smbst)) {
+			bus->stop_ind = SMB_SLAVE_XMIT_IND;
 		} else {
-			// Slave got an address match with direction bit clear so it
-			//	should receive data.
-			// this module does not support saying no to bytes. it will always ACK.
-			pdebug_lvl2(bus, "CB: slv rcv");
-			//printk("s rcv\r\n");
-			npcm_i2c_slave_send_rd_buf(bus);
-			npcm_smb_slave_start_receive(
-				bus, bus->adap.quirks->max_read_len,
-				bus->slv_rd_buf);
+			bus->stop_ind = SMB_SLAVE_RCV_IND;
 		}
 
+		bus->state = SMB_SLAVE_MATCH;
+
+		npcm_i2c_slave_rd_wr(bus);
+
 		iowrite8(NPCM_SMBST_NMATCH, bus->reg + NPCM_SMBST);
 		ret = IRQ_HANDLED;
 	}
 
 	// Slave SDA status is set - transmit or receive, slave
-	if (FIELD_GET(NPCM_SMBST_SDAST, ioread8(bus->reg + NPCM_SMBST)) ||
+	if (FIELD_GET(NPCM_SMBST_SDAST, smbst) ||
 	    (bus->fifo_use &&
 	     (npcm_smb_tx_fifo_empty(bus) || npcm_smb_rx_fifo_full(bus)))) {
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "SDA slave set");
-		//printk("s sda\r\n");
-		// Perform slave read. No need to distinguish between last byte and the rest of the bytes.
-		if ((NPCM_SMBST_XMIT & ioread8(bus->reg + NPCM_SMBST)) == 0) {
-			bus->operation = SMB_READ_OPER;
-			npcm_smb_read_from_fifo(
-				bus, npcm_smb_get_fifo_fullness(bus));
-			//printk("s sda-r\r\n");
-			bus->stop_ind = SMB_SLAVE_RCV_IND;
+#endif /* I2C_DEBUG */
 
-			// Slave got an address match with direction bit clear so it
-			//	should receive data.
-			// this module does not support saying no to bytes. it will always ACK.
-			npcm_i2c_slave_send_rd_buf(bus);
-			npcm_smb_slave_start_receive(
-				bus, bus->adap.quirks->max_read_len,
-				bus->slv_rd_buf);
-
-		}
-		// Perform slave write.
-		else {
-			// Slave got an address match with direction bit set so it
-			//	should transmit data
-			// Write till the master will NACK
-			//printk("s sda-w\r\n");
-			npcm_smb_slave_start_xmit(
-				bus, bus->adap.quirks->max_write_len,
-				bus->slv_wr_buf);
-		}
+		npcm_i2c_slave_rd_wr(bus);
 
 		iowrite8(NPCM_SMBST_SDAST, bus->reg + NPCM_SMBST);
 
@@ -1792,9 +1590,8 @@ static int npcm_i2c_reg_slave(struct i2c_client *client)
 
 	bus->slave = client;
 
-	if (!bus->slave) {
+	if (!bus->slave)
 		return -EINVAL;
-	}
 
 	if (client->flags & I2C_CLIENT_TEN)
 		return -EAFNOSUPPORT;
@@ -1802,11 +1599,15 @@ static int npcm_i2c_reg_slave(struct i2c_client *client)
 	spin_lock_irqsave(&bus->lock, lock_flags);
 
 	npcm_smb_init_params(bus);
+	bus->slv_rd_size = 0;
+	bus->slv_wr_size = 0;
+	bus->slv_rd_ind = 0;
+	bus->slv_wr_ind = 0;
+	if (client->flags & I2C_CLIENT_PEC)
+		bus->PEC_use = true;
 
-	bus->own_slave_addr = client->addr;
-
-	pr_err("I2C%d register slave SA=0x%x, PEC=%d\n", bus->num, client->addr,
-	       bus->PEC_use);
+	pr_info("I2C%d register slave SA=0x%x, PEC=%d\n", bus->num,
+		client->addr, bus->PEC_use);
 
 	npcm_smb_select_bank(bus, SMB_BANK_0);
 
@@ -1869,20 +1670,14 @@ static void npcm_smb_master_fifo_read(struct npcm_i2c *bus)
 	if ((rcount - fifo_bytes) <= 0) {
 		// last bytes are about to be read - end of transaction.
 		// Stop should be set before reading last byte.
-
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ4);
 
-		if (npcm_smb_get_PEC(bus) != 0)
-			ind = SMB_MASTER_PEC_ERR_IND;
-
 		bus->state = SMB_STOP_PENDING;
 		bus->stop_ind = ind;
 
 		npcm_smb_eob_int(bus, true);
 		npcm_smb_master_stop(bus);
-
 		npcm_smb_read_from_fifo(bus, fifo_bytes);
-
 	} else {
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ3);
 		npcm_smb_read_from_fifo(bus, fifo_bytes);
@@ -1896,16 +1691,18 @@ static void npcm_smb_int_master_handler_write(struct npcm_i2c *bus)
 	u16 wcount;
 
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_WRITE);
+#ifdef _I2C_DEBUG_
 	pdebug_lvl2(bus, "handler wr");
+#endif /* I2C_DEBUG */
 	if (bus->fifo_use)
 		npcm_smb_clear_tx_fifo(bus); // clear the TX fifo status bit
 
 	// Master write operation - last byte handling
 	if (bus->wr_ind == bus->wr_size) {
-		pdebug_lvl2(bus, "last wr");
 		if (bus->fifo_use && npcm_smb_get_fifo_fullness(bus) > 0)
-			// No more bytes to send (to add to the FIFO), however the FIFO is not
-			// empty yet. It is still in the middle of tx. Currently there's nothing
+			// No more bytes to send (to add to the FIFO),
+			// however the FIFO is not empty yet. It is
+			// still in the middle of tx. Currently there's nothing
 			// to do except for waiting to the end of the tx.
 			// We will get an int when the FIFO will get empty.
 			return;
@@ -1925,23 +1722,18 @@ static void npcm_smb_int_master_handler_write(struct npcm_i2c *bus)
 		} else {
 			// last write-byte written on previous int - need to
 			// restart & send slave address
-			if (bus->PEC_use && !bus->read_block_use &&
-			    !npcm_smb_is_quick(bus))
-				// PEC is used but the protocol is not block read
-				// then we add extra bytes for PEC support
-				bus->rd_size += 1;
-
 			npcm_smb_set_fifo(bus, bus->rd_size, -1);
 
 			// Generate (Repeated) Start upon next write to SDA
 			npcm_smb_master_start(bus);
 
 			if (bus->rd_size == 1)
-
-				// Receiving one byte only - stall after successful completion of send
-				// address byte. If we NACK here, and slave doesn't ACK the address, we
-				// might unintentionally NACK the next multi-byte read
-
+				// Receiving one byte only - stall after
+				// successful completion of send
+				// address byte. If we NACK here,
+				// and slave doesn't ACK the address, we
+				// might unintentionally NACK the next
+				// multi-byte read
 				npcm_smb_stall_after_start(bus, true);
 
 			// Next int will occur on read
@@ -1951,28 +1743,19 @@ static void npcm_smb_int_master_handler_write(struct npcm_i2c *bus)
 			npcm_smb_wr_byte(bus, bus->dest_addr | 0x1);
 		}
 	} else {
-		if (bus->PEC_use && !npcm_smb_is_quick(bus))
-			// extra bytes for PEC support
-			bus->wr_size += 1;
-
 		// write next byte not last byte and not slave address
 		if (!bus->fifo_use || bus->wr_size == 1) {
-			if (bus->PEC_use && bus->rd_size == 0 &&
-			    (bus->wr_ind + 1 == bus->wr_size)) {
-				// Master write protocol to send PEC byte.
-				npcm_smb_write_PEC(bus);
-				bus->wr_ind++;
-			} else {
-				npcm_smb_wr_byte(bus,
-						 bus->wr_buf[bus->wr_ind++]);
-			}
-		} else { // FIFO is used
+			npcm_smb_wr_byte(bus, bus->wr_buf[bus->wr_ind++]);
+		} else {
 			wcount = bus->wr_size - bus->wr_ind;
 			npcm_smb_set_fifo(bus, -1, wcount);
-			//   WHY NOT: npcm_smb_write_to_fifo_master(bus, wcount);
 			npcm_smb_write_to_fifo_master(bus, wcount);
 		}
 	}
+
+#ifdef _I2C_DEBUG_
+	pdebug_lvl2(bus, "handler_wr_e");
+#endif /* I2C_DEBUG */
 }
 
 static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
@@ -1982,16 +1765,12 @@ static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 
 	// Master read operation (pure read or following a write operation).
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ);
+#ifdef _I2C_DEBUG_
 	pdebug_lvl2(bus, "handler rd");
+#endif /* I2C_DEBUG */
 
-	if (bus->rd_ind > bus->rd_size)
-		pdebug_lvl2(bus, "master rd error");
-
-	// Initialize number of bytes to include only the first byte (presents
-	// a case where number of bytes to read is zero); add PEC if applicable
-	block_extra_bytes_size = 1;
-	if (bus->PEC_use)
-		block_extra_bytes_size++;
+	// added bytes to the packet:
+	block_extra_bytes_size = (u8)bus->read_block_use + (u8)bus->PEC_use;
 
 	// Perform master read, distinguishing between last byte and the rest of
 	// the bytes. The last byte should be read when the clock is stopped
@@ -2002,10 +1781,7 @@ static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 			// first byte in block protocol is the size:
 			npcm_smb_rd_byte(bus, &data);
 
-			if (bus->PEC_use)
-				data += 1;
-
-			// if slave returned illgal size. read up to 32 bytes.
+			// if slave returned illegal size. read up to 32 bytes.
 			if (data >= I2C_SMBUS_BLOCK_MAX)
 				data = I2C_SMBUS_BLOCK_MAX;
 
@@ -2015,7 +1791,6 @@ static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 
 			bus->rd_size = data + block_extra_bytes_size;
 
-			// First byte indicates length in block protocol
 			bus->rd_buf[bus->rd_ind++] = data;
 
 			// clear RX FIFO interrupt status:
@@ -2024,7 +1799,6 @@ static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 						 ioread8(bus->reg +
 							 NPCM_SMBFIF_CTS),
 					 bus->reg + NPCM_SMBFIF_CTS);
-				//npcm_smb_clear_fifo_int(bus);
 			}
 
 			npcm_smb_set_fifo(bus, (bus->rd_size - 1), -1);
@@ -2035,64 +1809,98 @@ static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 			npcm_smb_clear_tx_fifo(bus);
 			npcm_smb_master_fifo_read(bus);
 		}
-
 	} else {
 		if (bus->rd_size == block_extra_bytes_size &&
 		    bus->read_block_use) {
+#ifdef _I2C_DEBUG_
+			pdebug_lvl2(bus, "ERR_IND");
+#endif /* I2C_DEBUG */
 			bus->state = SMB_STOP_PENDING;
 			bus->stop_ind = SMB_BLOCK_BYTES_ERR_IND;
+			bus->cmd_err = -EIO;
 			npcm_smb_eob_int(bus, true);
 			npcm_smb_master_stop(bus);
 			npcm_smb_read_from_fifo(
 				bus, npcm_smb_get_fifo_fullness(bus));
-
 		} else {
 			NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ2);
 			npcm_smb_master_fifo_read(bus);
 		}
 	}
+
+#ifdef _I2C_DEBUG_
+	pdebug_lvl2(bus, "handler_rd_e");
+#endif /* I2C_DEBUG */
 }
 
 static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 {
 	irqreturn_t ret = IRQ_NONE;
-	u8 smbfif_cts;
+	u8 fif_cts;
 
+	if (FIELD_GET(NPCM_SMBST_NMATCH, ioread8(bus->reg + NPCM_SMBST))) {
+		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NMATCH_MSTR);
+		iowrite8(NPCM_SMBST_NMATCH, bus->reg + NPCM_SMBST);
+		npcm_smb_nack(bus);
+		bus->stop_ind = SMB_BUS_ERR_IND;
+		npcm_smb_callback(bus, bus->stop_ind, npcm_smb_get_index(bus));
+
+		return IRQ_HANDLED;
+	}
 	// A negative acknowledge has occurred
 	if (FIELD_GET(NPCM_SMBST_NEGACK, ioread8(bus->reg + NPCM_SMBST))) {
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NACK);
 		if (bus->fifo_use) {
 			// if there are still untransmitted bytes in TX FIFO
 			// reduce them from wr_ind
-			if (3 == bus->num) {
-				//printk("m nack:0x%x\r\n", ioread8(bus->reg + NPCM_SMBST));
-				//printk("m cst:0x%x\r\n", ioread8(bus->reg + NPCM_SMBCST));
-			}
+
 			if (bus->operation == SMB_WRITE_OPER)
 				bus->wr_ind -= npcm_smb_get_fifo_fullness(bus);
+
 			// clear the FIFO
 			iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
 				 bus->reg + NPCM_SMBFIF_CTS);
 		}
 
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "NACK");
+#endif /* I2C_DEBUG */
 
 		// In master write operation, NACK is a problem
 		// number of bytes sent to master less than required
 		bus->stop_ind = SMB_NACK_IND;
-		npcm_smb_master_abort(bus);
+		// Only current master is allowed to issue Stop Condition
+		if (npcm_smb_is_master(bus)) {
+			// stopping in the middle, not waiting for ints anymore
+			npcm_smb_eob_int(bus, false);
+
+			// Generate a STOP condition after next wr\rd from fifo:
+			npcm_smb_master_stop(bus);
+
+			// Clear NEGACK, STASTR and BER bits
+			// In Master mode, NEGACK should be cleared only after
+			// generating STOP.
+			// In such case, the bus is released from stall only
+			// after the software clears NEGACK bit.
+			// Then a Stop condition is sent.
+			iowrite8(NPCM_SMBST_BER | NPCM_SMBST_NEGACK |
+					 NPCM_SMBST_STASTR,
+				 bus->reg + NPCM_SMBST);
+
+			npcm_smb_wait_for_bus_free(bus, false);
+		}
 		bus->state = SMB_IDLE;
 
+		//******************if (unlikely(bus->operation == SMB_READ_OPER))
+		//******************		npcm_smb_reset(bus);
+
 		// In Master mode, NEGACK should be cleared only after
 		// generating STOP.
 		// In such case, the bus is released from stall only after the
 		// software clears NEGACK bit.
 		// Then a Stop condition is sent.
-		iowrite8(NPCM_SMBST_NEGACK, bus->reg + NPCM_SMBST);
 		npcm_smb_callback(bus, bus->stop_ind, bus->wr_ind);
-		ret = IRQ_HANDLED;
-
-		return ret;
+		return IRQ_HANDLED;
 	}
 
 	// Master mode: a Bus Error has been identified
@@ -2100,28 +1908,17 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 		// Check whether bus arbitration or Start or Stop during data
 		// xfer bus arbitration problem should not result in recovery
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_BER);
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "BER_M");
-		if (3 == bus->num) {
-			//printk("m ber\r\n");
-		}
+#endif /* I2C_DEBUG */
+
+		bus->stop_ind = SMB_BUS_ERR_IND;
 		if (npcm_smb_is_master(bus)) {
-			// Only current master is allowed to issue stop
-			bus->stop_ind = SMB_BUS_ERR_IND;
+			// Only current master is allowed to issue abort
 			npcm_smb_master_abort(bus);
-		} else {
-			// Bus arbitration loss
-			if (bus->retry_count-- > 1) {
-				// Perform a retry (generate a start condition)
-				// as soon as the SMBus is free
-				pdebug_lvl2(bus, "retry-BER");
-				iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
-				npcm_smb_master_start(bus);
-				return IRQ_HANDLED;
-			}
 		}
 		iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
 		bus->state = SMB_IDLE;
-		bus->stop_ind = SMB_BUS_ERR_IND;
 		npcm_smb_callback(bus, bus->stop_ind, npcm_smb_get_index(bus));
 		ret = IRQ_HANDLED;
 	}
@@ -2133,23 +1930,23 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 	    (FIELD_GET(NPCM_SMBCST3_EO_BUSY,
 		       ioread8(bus->reg + NPCM_SMBCST3)))) {
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_EOB);
-		if (3 == bus->num) {
-			//printk("m eob\r\n");
-		}
+
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "EOB  ");
+#endif /* I2C_DEBUG */
 		npcm_smb_eob_int(bus, false);
 		bus->state = SMB_IDLE;
 		npcm_smb_callback(bus, bus->stop_ind, bus->rd_ind);
-		ret = IRQ_HANDLED;
+		return IRQ_HANDLED;
 	}
 
 	// Address sent and requested stall occurred (Master mode)
 	if (FIELD_GET(NPCM_SMBST_STASTR, ioread8(bus->reg + NPCM_SMBST))) {
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "stall");
+#endif /* I2C_DEBUG */
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_STALL);
-		if (3 == bus->num) {
-			//printk("m stall\r\n");
-		}
+
 		// Check for Quick Command SMBus protocol
 		if (npcm_smb_is_quick(bus)) {
 			// Update status
@@ -2179,84 +1976,76 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 	     (npcm_smb_tx_fifo_empty(bus) || npcm_smb_rx_fifo_full(bus)))) {
 		// Status Bit is cleared by writing to or reading from SDA
 		// (depending on current direction)
-		if (3 == bus->num) {
-			//printk("state: 0x%x\r\n",bus->state);
-		}
 
 		// Send address:
 		if (bus->state == SMB_IDLE) {
 			if (npcm_smb_is_master(bus)) {
 				bus->stop_ind = SMB_WAKE_UP_IND;
 
-				bus->crc_data = 0;
-
 				// test stall on start
 				if (npcm_smb_is_quick(bus) ||
-				    (bus->read_block_use == true)) {
+				    bus->read_block_use)
 					// Need to stall after successful
 					// completion of sending address byte
 					npcm_smb_stall_after_start(bus, true);
-				} else {
+				else
 					npcm_smb_stall_after_start(bus, false);
-				}
-				// Receiving one byte only - stall after successful completion of
-				// sending address byte. If we NACK here, and slave doesn't ACK the
-				// address, we might unintentionally NACK the next multi-byte read
+
+				// Receiving one byte only - stall after
+				// successful completion of sending address byte
+				// If we NACK here, and slave doesn't ACK the
+				// address, we might unintentionally NACK
+				// the next multi-byte read
 				if (bus->wr_size == 0 && bus->rd_size == 1)
 					npcm_smb_stall_after_start(bus, true);
 
-#if 0
 				// Initiate SMBus master transaction
 				// Generate a Start condition on the SMBus
 
 				// select bank 1 for FIFO regs
 				npcm_smb_select_bank(bus, SMB_BANK_1);
 
-				smbfif_cts = ioread8(bus->reg + NPCM_SMBFIF_CTS);
+				fif_cts = ioread8(bus->reg + NPCM_SMBFIF_CTS);
 
 				// clear FIFO and relevant status bits.
-				iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
-					 NPCM_SMBFIF_CTS_CLR_FIFO,
+				iowrite8((fif_cts & ~NPCM_SMBFIF_CTS_SLVRSTR) |
+						 NPCM_SMBFIF_CTS_CLR_FIFO,
 					 bus->reg + NPCM_SMBFIF_CTS);
 
 				// and enable it
-				iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
-					 NPCM_SMBFIF_CTS_RXF_TXE,
+				iowrite8((fif_cts & ~NPCM_SMBFIF_CTS_SLVRSTR) |
+						 NPCM_SMBFIF_CTS_RXF_TXE,
 					 bus->reg + NPCM_SMBFIF_CTS);
 
-				// Configure the FIFO
-				//threshold according to the needed # of bytes to read.
-				npcm_smb_set_fifo(bus, bus->rd_size, bus->wr_size);
-#endif
+				// Configure the FIFO threshold
+				// according to the needed # of bytes to read.
+				// Note: due to HW limitation can't config the rx fifo before
+				// got and ACK on the restart. LAST bit will not be reset unless
+				// RX completed. It will stay set on the next tx.
+				if (bus->wr_size)
+					npcm_smb_set_fifo(bus, -1,
+							  bus->wr_size);
+				else
+					npcm_smb_set_fifo(bus, bus->rd_size,
+							  -1);
+
 				bus->state = SMB_OPER_STARTED;
 
-				if (npcm_smb_is_quick(bus) ||
-				    (bus->wr_size > 0)) {
-					if (3 == bus->num) {
-						//printk("m w-a:0x%x\r\n", bus->dest_addr);
-					}
+				if (npcm_smb_is_quick(bus) || bus->wr_size)
 					npcm_smb_wr_byte(bus, bus->dest_addr);
-				} else
+				else
 					npcm_smb_wr_byte(bus,
 							 bus->dest_addr | 0x01);
 			}
 
 			return IRQ_HANDLED;
-
-		}
-		// SDA status is set - transmit or receive: Handle master mode
-		else {
+			// SDA status is set - transmit or receive: Handle master mode
+		} else {
 			if ((NPCM_SMBST_XMIT &
 			     ioread8(bus->reg + NPCM_SMBST)) == 0) {
-				if (3 == bus->num) {
-					//printk("m rd\r\n");
-				}
 				bus->operation = SMB_READ_OPER;
 				npcm_smb_int_master_handler_read(bus);
 			} else {
-				if (3 == bus->num) {
-					//printk("m wr\r\n");
-				}
 				bus->operation = SMB_WRITE_OPER;
 				npcm_smb_int_master_handler_write(bus);
 			}
@@ -2270,32 +2059,32 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 static int npcm_smb_recovery(struct i2c_adapter *_adap)
 {
 	u8 iter = 27; // Allow one byte to be sent by the Slave
-	u16 timeout;
+	u16 retries;
 	bool done = false;
 	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
 
 	dev_err(bus->dev, "recovery bus%d\n", bus->num);
 
-	might_sleep();
+	if ((npcm_smb_get_SDA(_adap) == 1) && (npcm_smb_get_SCL(_adap) == 1))
+		return 0;
 
 	// Disable int
 	npcm_smb_int_enable(bus, false);
 
 	// Check If the SDA line is active (low)
-	if (FIELD_GET(NPCM_SMBCST_TSDA, ioread8(bus->reg + NPCM_SMBCST)) == 0) {
+	if (npcm_smb_get_SDA(_adap) == 0) {
 		// Repeat the following sequence until SDA is released
 		do {
 			// Issue a single SCL cycle
 			iowrite8(NPCM_SMBCST_TGSCL, bus->reg + NPCM_SMBCST);
-			timeout = ABORT_TIMEOUT;
-			while (timeout != 0 &&
+			retries = RETRIES_NUM;
+			while (retries != 0 &&
 			       FIELD_GET(NPCM_SMBCST_TGSCL,
-					 ioread8(bus->reg + NPCM_SMBCST) == 0))
-				timeout--;
+					 ioread8(bus->reg + NPCM_SMBCST)))
+				retries--;
 
 			// If SDA line is inactive (high), stop
-			if (FIELD_GET(NPCM_SMBCST_TSDA,
-				      ioread8(bus->reg + NPCM_SMBCST)) == 1)
+			if (npcm_smb_get_SDA(_adap))
 				done = true;
 		} while ((!done) && (--iter != 0));
 
@@ -2307,19 +2096,20 @@ static int npcm_smb_recovery(struct i2c_adapter *_adap)
 			// Generate a START, to synchronize Master and Slave
 			npcm_smb_master_start(bus);
 
-			// Wait until START condition is sent, or timeout
-			timeout = ABORT_TIMEOUT;
-			while (timeout != 0 && !npcm_smb_is_master(bus))
-				timeout--;
+			// Wait until START condition is sent, or RETRIES_NUM
+			retries = RETRIES_NUM;
+			while (retries && !npcm_smb_is_master(bus))
+				retries--;
 
 			// If START condition was sent
-			if (timeout > 0) {
+			if (retries > 0) {
 				// Send an address byte in write direction:
 				npcm_smb_wr_byte(bus, bus->dest_addr);
 
 				// Generate a STOP condition
 				npcm_smb_master_stop(bus);
 			}
+			npcm_smb_int_enable(bus, true);
 			return 0;
 		}
 	}
@@ -2360,31 +2150,31 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 		sclfrq = 0;
 		fast_mode = true;
 
-		if ((mode == SMB_MASTER && src_clk_freq < 7500) ||
-		    (mode == SMB_SLAVE && src_clk_freq < 10000))
-			// 400KHZ cannot be supported for master core clock < 7.5 MHZ
-			// or slave core clock < 10 MHZ
+		if (src_clk_freq < 7500)
+			// 400KHZ cannot be supported for core clock < 7.5 MHZ
 			return false;
 
+		else if (src_clk_freq >= 50000) {
+			k1 = 80;
+			k2 = 48;
+			hldt = 12;
+			dbnct = 7;
+		}
+
 		// Master or Slave with frequency > 25 MHZ
-		if (mode == SMB_MASTER || src_clk_freq > 25000) {
+		else if (src_clk_freq > 25000) {
 			hldt = (u8)__KERNEL_DIV_ROUND_UP(src_clk_freq * 300,
 							 1000000) +
 			       7;
-			if (mode == SMB_MASTER) {
-				k1 = __KERNEL_DIV_ROUND_UP(src_clk_freq * 1600,
-							   1000000);
-				k2 = __KERNEL_DIV_ROUND_UP(src_clk_freq * 900,
-							   1000000);
-				k1 = round_up(k1, 2);
-				k2 = round_up(k2 + 1, 2);
-				if (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX ||
-				    k2 < SCLFRQ_MIN || k2 > SCLFRQ_MAX)
-					return false;
-			}
-		} else { // Slave with frequency 10-25 MHZ
-			hldt = 7;
-			dbnct = 2;
+
+			k1 = __KERNEL_DIV_ROUND_UP(src_clk_freq * 1600,
+						   1000000);
+			k2 = __KERNEL_DIV_ROUND_UP(src_clk_freq * 900, 1000000);
+			k1 = round_up(k1, 2);
+			k2 = round_up(k2 + 1, 2);
+			if (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX ||
+			    k2 < SCLFRQ_MIN || k2 > SCLFRQ_MAX)
+				return false;
 		}
 	}
 
@@ -2392,36 +2182,31 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 		sclfrq = 0;
 		fast_mode = true;
 
-		if ((mode == SMB_MASTER && src_clk_freq < 15000) ||
-		    (mode == SMB_SLAVE && src_clk_freq < 24000))
+		if (src_clk_freq < 24000)
 			// 1MHZ cannot be supported for master core clock < 15 MHZ
 			// or slave core clock < 24 MHZ
 			return false;
 
-		if (mode == SMB_MASTER) {
-			k1 = round_up((__KERNEL_DIV_ROUND_UP(src_clk_freq * 620,
-							     1000000)),
-				      2);
-			k2 = round_up((__KERNEL_DIV_ROUND_UP(src_clk_freq * 380,
-							     1000000) +
-				       1),
-				      2);
-			if (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX ||
-			    k2 < SCLFRQ_MIN || k2 > SCLFRQ_MAX) {
-				return false;
-			}
-		}
+		k1 = round_up(
+			(__KERNEL_DIV_ROUND_UP(src_clk_freq * 620, 1000000)),
+			2);
+		k2 = round_up(
+			(__KERNEL_DIV_ROUND_UP(src_clk_freq * 380, 1000000) +
+			 1),
+			2);
+		if (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX || k2 < SCLFRQ_MIN ||
+		    k2 > SCLFRQ_MAX)
+			return false;
 
 		// Master or Slave with frequency > 40 MHZ
-		if (mode == SMB_MASTER || src_clk_freq > 40000) {
+		if (src_clk_freq > 40000) {
 			// Set HLDT:
 			// SDA hold time:  (HLDT-7) * T(CLK) >= 120
 			// HLDT = 120/T(CLK) + 7 = 120 * FREQ(CLK) + 7
 			hldt = (u8)__KERNEL_DIV_ROUND_UP(src_clk_freq * 120,
 							 1000000) +
 			       7;
-
-			// Slave with frequency 24-40 MHZ
+			//
 		} else {
 			hldt = 7;
 			dbnct = 2;
@@ -2432,49 +2217,33 @@ static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
 	else
 		return false;
 
-	// After clock parameters calculation update the reg
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL2) & ~SMBCTL2_SCLFRQ6_0) |
-			 FIELD_PREP(SMBCTL2_SCLFRQ6_0, sclfrq & 0x7F),
+	// After clock parameters calculation update reg (ENABLE should be 0):
+	iowrite8(FIELD_PREP(SMBCTL2_SCLFRQ6_0, sclfrq & 0x7F),
 		 bus->reg + NPCM_SMBCTL2);
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_SCLFRQ8_7) |
+	// force to bank 0, set SCL and fast mode
+	iowrite8(FIELD_PREP(SMBCTL3_400K_MODE, fast_mode) |
 			 FIELD_PREP(SMBCTL3_SCLFRQ8_7, (sclfrq >> 7) & 0x3),
 		 bus->reg + NPCM_SMBCTL3);
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_400K_MODE) |
-			 FIELD_PREP(SMBCTL3_400K_MODE, fast_mode),
-		 bus->reg + NPCM_SMBCTL3);
-
 	// Select Bank 0 to access NPCM_SMBCTL4/NPCM_SMBCTL5
 	npcm_smb_select_bank(bus, SMB_BANK_0);
 
 	if (bus_freq >= SMBUS_FREQ_400KHZ) {
-		// k1 and k2 are relevant for master mode only
-		if (mode == SMB_MASTER) {
-			// Set SCL Low/High Time:
-			// k1 = 2 * SCLLT7-0 -> Low Time  = k1 / 2
-			// k2 = 2 * SCLLT7-0 -> High Time = k2 / 2
-			iowrite8((u8)k1 / 2, bus->reg + NPCM_SMBSCLLT);
-			iowrite8((u8)k2 / 2, bus->reg + NPCM_SMBSCLHT);
-		} else { // DBNCT is relevant for slave mode only
-			iowrite8((ioread8(bus->reg + NPCM_SMBCTL5) &
-				  ~SMBCTL5_DBNCT) |
-					 FIELD_PREP(SMBCTL5_DBNCT, dbnct),
-				 bus->reg + NPCM_SMBCTL5);
-		}
+		// Set SCL Low/High Time:
+		// k1 = 2 * SCLLT7-0 -> Low Time  = k1 / 2
+		// k2 = 2 * SCLLT7-0 -> High Time = k2 / 2
+		iowrite8((u8)k1 / 2, bus->reg + NPCM_SMBSCLLT);
+		iowrite8((u8)k2 / 2, bus->reg + NPCM_SMBSCLHT);
+
+		iowrite8(dbnct, bus->reg + NPCM_SMBCTL5);
 	}
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL4) & ~SMBCTL4_HLDT) |
-			 FIELD_PREP(SMBCTL4_HLDT, hldt),
-		 bus->reg + NPCM_SMBCTL4);
+	iowrite8(hldt, bus->reg + NPCM_SMBCTL4);
 
 	// Return to Bank 1, and stay there by default:
 	npcm_smb_select_bank(bus, SMB_BANK_1);
 
-	dev_dbg(bus->dev,
-		"k1 = %d k2 = %d dbnct = %d sclfrq = %d hldt = %d src_clk_freq %d fast_mode %d\n",
-		k1, k2, dbnct, sclfrq, hldt, src_clk_freq, fast_mode);
-
 	return true;
 }
 
@@ -2485,10 +2254,11 @@ static bool npcm_smb_init_module(struct npcm_i2c *bus, enum smb_mode mode,
 	if ((bus->state != SMB_DISABLE && bus->state != SMB_IDLE) ||
 	    bus_freq < SMBUS_FREQ_MIN || bus_freq > SMBUS_FREQ_MAX)
 		return false;
-	// Configure FIFO disabled mode so slave will not use fifo
-	// (maste will set it on if supported)
+
 	bus->threshold_fifo = SMBUS_FIFO_SIZE;
 
+	npcm_smb_disable(bus);
+
 	// Configure FIFO mode :
 	if (FIELD_GET(SMB_VER_FIFO_EN, ioread8(bus->reg + SMB_VER))) {
 		bus->fifo_use = true;
@@ -2506,7 +2276,6 @@ static bool npcm_smb_init_module(struct npcm_i2c *bus, enum smb_mode mode,
 		pr_err("npcm_smb_init_clk failed\n");
 		return false;
 	}
-	npcm_smb_disable(bus);
 
 	// Enable module (before configuring CTL1)
 	npcm_smb_enable(bus);
@@ -2534,6 +2303,7 @@ static int __npcm_i2c_init(struct npcm_i2c *bus, struct platform_device *pdev)
 	bus->master_or_slave = SMB_SLAVE;
 	bus->int_time_stamp = 0;
 	bus->slave = NULL;
+	bus->xmits = 0;
 
 	ret = of_property_read_u32(pdev->dev.of_node, "bus-frequency",
 				   &clk_freq);
@@ -2548,8 +2318,6 @@ static int __npcm_i2c_init(struct npcm_i2c *bus, struct platform_device *pdev)
 		return -1;
 	}
 
-	crc8_populate_lsb(npcm7xx_crc8, 0x07);
-	crc8_populate_msb(npcm7xx_crc8, 0x07);
 	return 0;
 }
 
@@ -2560,32 +2328,23 @@ static irqreturn_t npcm_i2c_bus_irq(int irq, void *dev_id)
 
 	bus->int_cnt++;
 
-	//spin_lock(&bus->lock);
-
 	if (npcm_smb_is_master(bus))
 		bus->master_or_slave = SMB_MASTER;
 
 	if (bus->master_or_slave == SMB_MASTER) {
 		bus->int_time_stamp = jiffies;
 		ret = npcm_smb_int_master_handler(bus);
-		if (ret == IRQ_HANDLED) {
-			//spin_unlock(&bus->lock);
+		if (ret == IRQ_HANDLED)
 			return ret;
-		}
 	}
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
 	if (bus->slave) {
 		bus->master_or_slave = SMB_SLAVE;
 		ret = npcm_smb_int_slave_handler(bus);
-		if (ret == IRQ_HANDLED) {
-			//spin_unlock(&bus->lock);
+		if (ret == IRQ_HANDLED)
 			return ret;
-		}
 	}
 #endif
-
-	//spin_unlock(&bus->lock);
-
 	return IRQ_HANDLED;
 }
 
@@ -2594,17 +2353,16 @@ static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus, u8 slave_addr,
 				       u8 *read_data, bool use_PEC,
 				       bool use_read_block)
 {
-	// Allow only if bus is not busy
 	if (bus->state != SMB_IDLE) {
+#ifdef _I2C_DEBUG_
 		pdebug_lvl2(bus, "xmit not IDLE\n");
-		if (3 == bus->num) {
-			//printk("xmit not idle 1!!!\r\n");
-		}
+#endif /* I2C_DEBUG */
+		bus->cmd_err = -(EBUSY);
 		return false;
 	}
-	if (3 == bus->num) {
-		//printk("bus->state: 0x%x\r\n", bus->state);
-	}
+
+	bus->xmits++;
+
 	bus->dest_addr = (u8)(slave_addr << 1); // Translate 7bit to 8bit format
 	bus->wr_buf = write_data;
 	bus->wr_size = nwrite;
@@ -2612,20 +2370,20 @@ static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus, u8 slave_addr,
 	bus->rd_buf = read_data;
 	bus->rd_size = nread;
 	bus->rd_ind = 0;
-	bus->PEC_use = use_PEC;
-	bus->PEC_mask = 0;
-	bus->retry_count = 0; // SMB_RETRY_MAX_COUNT;
-	bus->read_block_use = use_read_block;
+	bus->PEC_use = 0;
 
-	if (nread > 0)
+	// for write, PEC is appended to buffer from i2c IF. PEC flag is ignored
+	if (nread)
+		bus->PEC_use = use_PEC;
+	bus->read_block_use = use_read_block;
+	if (nread && !nwrite)
 		bus->operation = SMB_READ_OPER;
 	else
 		bus->operation = SMB_WRITE_OPER;
 
 	bus->int_cnt = 0;
 	bus->event_log = 0;
-	pdebug_lvl2(bus, "xmit ");
-#if 1
+
 	if (bus->fifo_use) {
 		u8 smbfif_cts;
 		// select bank 1 for FIFO regs
@@ -2637,77 +2395,62 @@ static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus, u8 slave_addr,
 		iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
 				 NPCM_SMBFIF_CTS_CLR_FIFO,
 			 bus->reg + NPCM_SMBFIF_CTS);
-
-		// and enable it
-		iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
-				 NPCM_SMBFIF_CTS_RXF_TXE,
-			 bus->reg + NPCM_SMBFIF_CTS);
-
-		// Configure the FIFO
-		//threshold according to the needed # of bytes to read.
-		npcm_smb_set_fifo(bus, nread, nwrite);
 	}
-#endif
-	// Allow only if bus is not busy
-	if (bus->state != SMB_IDLE) {
-		if (3 == bus->num) {
-			//printk("xmit not idle!!!\r\n");
-		}
-		pdebug(bus, "xmit not IDLE\n");
-		return false;
-	}
-	bus->state = SMB_IDLE;
-	// bus->master_or_slave = SMB_MASTER;
 
-	if (npcm_smb_wait_for_bus_free(bus) == false)
-		return false;
+	bus->state = SMB_IDLE;
 
 	npcm_smb_stall_after_start(bus, true);
 	npcm_smb_master_start(bus);
-	if (3 == bus->num) {
-		//printk("xmit done\r\n");
-	}
+
 	return true;
 }
 
 static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 				int num)
 {
-	struct npcm_i2c *bus = adap->algo_data;
+	struct npcm_i2c *bus = container_of(adap, struct npcm_i2c, adap);
 	struct i2c_msg *msg0, *msg1;
 	unsigned long time_left, flags;
 	u16 nwrite, nread;
 	u8 *write_data, *read_data;
 	u8 slave_addr;
+	int timeout;
 	int ret = 0;
-	int timeout = bus->adap.timeout;
 	bool read_block = false;
+	bool read_PEC = false;
+	u8 bus_busy;
+
+	if (unlikely(bus->state == SMB_DISABLE)) {
+		pr_err("I2C%d module is disabled\n", bus->num);
+		pdebug_lvl2(bus, __func__);
+		return -EINVAL;
+	}
 
 	if (num > 2 || num < 1) {
 		pr_err("I2C command not supported, num of msgs = %d\n", num);
+		pdebug_lvl2(bus, __func__);
 		return -EINVAL;
 	}
 
-	spin_lock_irqsave(&bus->lock, flags);
-
 	msg0 = &msgs[0];
 	slave_addr = msg0->addr;
 	if (msg0->flags & I2C_M_RD) { // read
 		if (num == 2) {
-			pr_err(" num = 2 but first msg is rd instead of wr\n");
-			ret = -EINVAL;
-			goto xfer_end;
+			pr_err("I2C num = 2 but first msg is rd instead of wr\n");
+			pdebug_lvl2(bus, __func__);
+			return -EINVAL;
 		}
 		nwrite = 0;
 		write_data = NULL;
+		read_data = msg0->buf;
 		if (msg0->flags & I2C_M_RECV_LEN) {
 			nread = 1;
-			bus->read_block_use = true;
+			read_block = true;
+			if (msg0->flags & I2C_CLIENT_PEC)
+				read_PEC = true;
 		} else {
 			nread = msg0->len;
 		}
-		read_data = msg0->buf;
-
 	} else { // write
 		nwrite = msg0->len;
 		write_data = msg0->buf;
@@ -2715,63 +2458,92 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 		read_data = NULL;
 		if (num == 2) {
 			msg1 = &msgs[1];
+			read_data = msg1->buf;
 			if (slave_addr != msg1->addr) {
 				pr_err("SA==%02x but msg1->addr == %02x\n",
 				       slave_addr, msg1->addr);
-				ret = -EINVAL;
-				goto xfer_end;
+				pdebug_lvl2(bus, __func__);
+				return -EINVAL;
 			}
 			if ((msg1->flags & I2C_M_RD) == 0) {
 				pr_err("num = 2 but both msg are write.\n");
-				ret = -EINVAL;
-				goto xfer_end;
+				pdebug_lvl2(bus, __func__);
+				return -EINVAL;
 			}
 			if (msg1->flags & I2C_M_RECV_LEN) {
 				nread = 1;
 				read_block = true;
+				if (msg1->flags & I2C_CLIENT_PEC)
+					read_PEC = true;
 			} else {
 				nread = msg1->len;
 				read_block = false;
 			}
-
-			read_data = msg1->buf;
 		}
 	}
 
-	bus->msgs = msgs;
-	bus->msgs_num = num;
-
-	if (nread == 0 && nwrite == 0) {
+	if (nread == 0 && nwrite == 0)
 		timeout = msecs_to_jiffies(1);
-	} else if (read_block)
+	else if (read_block)
 		timeout = usecs_to_jiffies((2 + I2C_SMBUS_BLOCK_MAX + nwrite) *
 					   1300);
-	else {
+	else
 		// resonable assumption which leaves time for clock stretching.
 		timeout = usecs_to_jiffies((2 + nread + nwrite) * 1300);
-#if 1 //ifdef _I2C_DEBUG_
-		timeout = timeout * 1000;
-#endif
-	}
+
+#ifdef _I2C_DEBUG_
+	if (bus->num == BUS_TO_DEBUG)
+		timeout += msecs_to_jiffies(500);
+#endif /* I2C_DEBUG */
 
 	if (nwrite >= 32 * 1024 || nread >= 32 * 1024) {
 		pr_err("i2c%d buffer too big\n", bus->num);
-		ret = -EINVAL;
-		goto xfer_end;
+		pdebug_lvl2(bus, __func__);
+		return -EINVAL;
 	}
 
-	if (npcm_smb_wait_for_bus_free(bus) == false) {
-		ret = bus->cmd_err;
-		goto xfer_end;
+	time_left = jiffies + msecs_to_jiffies(DEFAULT_STALL_COUNT) + 1;
+
+	if ((bus->num == POWER_BRICK_BUS) &&
+	    ((bus->dest_addr >> 1) == POWER_BRICK_ADDRES))
+		udelay(200);
+
+	do {
+		/* we must clear slave address immediatly when the bus is not 
+		 * busy, so we spinlock it, but we don't keep the lock for the
+		 * entire while since it is too long.
+		 */
+		spin_lock_irqsave(&bus->lock, flags);
+		bus_busy = ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BB;
+		if (!bus_busy && bus->slave)
+			iowrite8((ioread8(bus->reg + NPCM_SMBADDR1) & 0x7F),
+				 bus->reg + NPCM_SMBADDR1);
+		spin_unlock_irqrestore(&bus->lock, flags);
+
+		if (!bus_busy)
+			break;
+	} while (jiffies < time_left);
+
+	if (bus_busy) {
+		// pr_err("i2c%d is busy\n", bus->num);
+		pdebug_lvl2(bus, __func__);
+		// Clear BB (BUS BUSY) bit
+		iowrite8(NPCM_SMBCST_BB, bus->reg + NPCM_SMBCST);
+		pdebug_lvl2(bus, __func__);
+		return -EAGAIN;
 	}
 
 	npcm_smb_init_params(bus);
+	bus->dest_addr = slave_addr;
+	bus->msgs = msgs;
+	bus->msgs_num = num;
+	bus->read_block_use = read_block;
 
 	reinit_completion(&bus->cmd_complete);
 
-	if (npcm_smb_master_start_xmit(bus, slave_addr, nwrite, nread,
-				       write_data, read_data, 0,
-				       read_block) == false)
+	if (!npcm_smb_master_start_xmit(bus, slave_addr, nwrite, nread,
+					write_data, read_data, read_PEC,
+					read_block))
 		ret = -(EBUSY);
 
 	if (ret != -(EBUSY)) {
@@ -2780,46 +2552,39 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 
 		if (time_left == 0) {
 			NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_TO);
-			pdebug_lvl2(bus, "xfer TO");
+
+#ifdef _I2C_DEBUG_
+			pdebug_lvl2(bus, "TO");
+#endif /* I2C_DEBUG */
 
 			if (bus->master_or_slave == SMB_MASTER) {
 				// timeout while bus is busy:
-				npcm_smb_master_abort(
-					bus); // don't stop in the middle.
+				npcm_smb_master_abort(bus);
 
-				// Reset driver status
 				bus->state = SMB_IDLE;
 			}
 		}
-		ret = bus->cmd_err;
-
-	} else {
-#if defined(CONFIG_I2C_DEBUG_BUS)
-		pdebug_lvl2(bus, "busy");
-#endif
 	}
+	ret = bus->cmd_err;
+	// reenable slave if it was enabled
+	if (bus->slave)
+		iowrite8((ioread8(bus->reg + NPCM_SMBADDR1) | 0x80),
+			 bus->reg + NPCM_SMBADDR1);
 
-xfer_end:
-	bus->msgs = NULL;
-	bus->msgs_num = 0;
-
-	if ((0xb == bus->num) && (0x36 == ((bus->dest_addr) >> 1))) {
-		udelay(200);
-	}
-
-	spin_unlock_irqrestore(&bus->lock, flags);
-
-	// If nothing went wrong, return number of messages xferred.
+	// If nothing went wrong, return number of messages x-ferred.
 	if (ret >= 0)
 		return num;
-	else
+	else {
+		// pr_err("i2c%d bus->cmd_err = %d\n", bus->num, ret);
+		pdebug_lvl2(bus, __func__);
 		return ret;
+	}
 }
 
 static u32 npcm_i2c_functionality(struct i2c_adapter *adap)
 {
 	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA |
-	       I2C_FUNC_SLAVE;
+	       I2C_FUNC_SLAVE | I2C_FUNC_SMBUS_PEC;
 }
 
 static const struct i2c_adapter_quirks npcm_i2c_quirks = {
@@ -2835,7 +2600,7 @@ static const struct i2c_algorithm npcm_i2c_algo = {
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
 	.reg_slave = npcm_i2c_reg_slave,
 	.unreg_slave = npcm_i2c_unreg_slave,
-#endif // CONFIG_I2C_SLAVE
+#endif
 };
 
 static struct i2c_bus_recovery_info npcm_i2c_recovery = {
@@ -2856,8 +2621,7 @@ static int npcm_i2c_probe_bus(struct platform_device *pdev)
 	bus = devm_kzalloc(&pdev->dev, sizeof(*bus), GFP_KERNEL);
 	if (!bus)
 		return -ENOMEM;
-	buss[bus->adap.nr] = bus;
-	printk("i2c driver debug version.\n");
+
 #ifdef CONFIG_OF
 	num = of_alias_get_id(pdev->dev.of_node, "i2c");
 	bus->num = num;
@@ -2899,8 +2663,8 @@ static int npcm_i2c_probe_bus(struct platform_device *pdev)
 	adap = &bus->adap;
 	adap->owner = THIS_MODULE;
 	adap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD | I2C_CLIENT_SLAVE;
-	adap->retries = 0;
-	adap->timeout = msecs_to_jiffies(25);
+	adap->retries = 5;
+	adap->timeout = HZ;
 	adap->algo = &npcm_i2c_algo;
 	adap->quirks = &npcm_i2c_quirks;
 	adap->algo_data = bus;
@@ -2912,13 +2676,9 @@ static int npcm_i2c_probe_bus(struct platform_device *pdev)
 	bus->dev = &pdev->dev;
 	bus->slave = NULL;
 
-	ret = __npcm_i2c_init(bus, pdev);
-	if (ret < 0)
-		return ret;
-
 	bus->irq = platform_get_irq(pdev, 0);
 	if (bus->irq < 0) {
-		pr_err("I2C platform_get_irq error.");
+		pr_err("I2C platform_get_irq error\n");
 		return -ENODEV;
 	}
 	dev_dbg(bus->dev, "irq = %d\n", bus->irq);
@@ -2931,6 +2691,10 @@ static int npcm_i2c_probe_bus(struct platform_device *pdev)
 		return ret;
 	}
 
+	ret = __npcm_i2c_init(bus, pdev);
+	if (ret < 0)
+		return ret;
+
 	i2c_set_adapdata(adap, bus);
 
 	snprintf(bus->adap.name, sizeof(bus->adap.name), "Nuvoton i2c");
@@ -2943,8 +2707,8 @@ static int npcm_i2c_probe_bus(struct platform_device *pdev)
 	}
 
 	platform_set_drvdata(pdev, bus);
+
 	pr_info("i2c bus %d registered\n", bus->adap.nr);
-	buss[bus->adap.nr] = bus;
 
 	return 0;
 }
-- 
2.22.0

